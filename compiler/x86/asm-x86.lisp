;;; asm-x86.lisp
;;;
;;; Copyright (C) 2007-2011 Peter Graves <gnooth@gmail.com>
;;;
;;; This program is free software; you can redistribute it and/or
;;; modify it under the terms of the GNU General Public License
;;; as published by the Free Software Foundation; either version 2
;;; of the License, or (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

(in-package "ASSEMBLER")

(defun emit-raw (x)
  (let ((bytes (list (ldb (byte 8  0) x)
                     (ldb (byte 8  8) x)
                     (ldb (byte 8 16) x)
                     (ldb (byte 8 24) x))))
    (dolist (byte bytes)
      (vector-push-extend byte *output*))))

(define-assembler :add
  (cond ((and (reg32-p operand1)
              (reg32-p operand2))
         (let* ((mod #b11)
                (reg (register-number operand1))
                (rm  (register-number operand2))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #x01 modrm-byte)))
        ((and (typep operand1 '(signed-byte 8))
              (reg32-p operand2))
         (let* ((mod #b11)
                (reg 0)
                (rm  (register-number operand2))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #x83 modrm-byte (ldb (byte 8 0) operand1))))
        ((and (typep operand1 '(signed-byte 32))
              (reg32-p operand2))
         (let* ((mod #b11)
                (reg 0)
                (rm  (register-number operand2))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #x81 modrm-byte)
           (emit-raw-dword operand1)))
        (t
         (unsupported))))

(define-assembler :and
  (cond ((and (reg32-p operand1)
              (reg32-p operand2))
         (let* ((mod #b11)
                (reg (register-number operand1))
                (rm  (register-number operand2))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #x21 modrm-byte)))
        ((and (typep operand1 '(unsigned-byte 8))
              (eq operand2 :al))
         (emit-bytes #x24 operand1))
        ((and (typep operand1 '(unsigned-byte 8))
              (reg8-p operand2))
         (let ((modrm-byte (make-modrm-byte #b11 4 (register-number operand2))))
           (emit-bytes #x80 modrm-byte (ldb (byte 8 0) operand1))))
        ((and (typep operand1 '(signed-byte 8))
              (reg32-p operand2))
         (let* ((mod #b11)
                (reg 4)
                (rm (register-number operand2))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #x83 modrm-byte (ldb (byte 8 0) operand1))))
        ((and (typep operand1 '(unsigned-byte 32))
              (eq operand2 :eax))
         (emit-byte #x25)
         (emit-raw operand1))
        ((and (typep operand1 '(unsigned-byte 32))
              (reg32-p operand2))
         (let* ((mod #b11)
                (reg 4)
                (rm (register-number operand2))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #x81 modrm-byte)
           (emit-raw operand1)))
        (t
         (unsupported))))

(defun assemble-bt* (mnemonic operand1 operand2)
  (cond ((and (reg32-p operand1)
              (consp operand2)
              (length-eql operand2 2)
              (typep (%car operand2) '(signed-byte 8))
              (reg32-p (%cadr operand2)))
         (let* ((displacement (%car operand2))
                (displacement-byte (ldb (byte 8 0) displacement))
                (mod #b01)
                (reg (register-number operand1))
                (rm  (register-number (%cadr operand2)))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #x0f
                       (ecase mnemonic
                         (:bt  #xa3)
                         (:bts #xab)
                         (:btr #xb3))
                       modrm-byte displacement-byte)))
        (t
         (unsupported))))

(define-assembler :bt
  (assemble-bt* :bt operand1 operand2))

(define-assembler :bts
  (assemble-bt* :bts operand1 operand2))

(define-assembler :btr
  (assemble-bt* :btr operand1 operand2))

(define-assembler :cmp
  (cond ((and (reg32-p operand1)
              (reg32-p operand2))
         (let* ((mod #b11)
                (reg (register-number operand1))
                (rm  (register-number operand2))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #x39 modrm-byte)))
        ((and (typep operand1 '(unsigned-byte 8))
              (eq operand2 :al))
         (emit-bytes #x3c operand1))
        ((and (typep operand1 '(unsigned-byte 8))
              (reg8-p operand2))
         (let ((modrm-byte (make-modrm-byte #b11 7 (register-number operand2))))
           (emit-bytes #x80 modrm-byte (ldb (byte 8 0) operand1))))
        ((and (typep operand1 '(signed-byte 8))
              (reg32-p operand2))
         (let* ((mod #b11)
                (reg 7)
                (rm  (register-number operand2))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #x83 modrm-byte (ldb (byte 8 0) operand1))))
        ((and (typep operand1 '(signed-byte 32))
              (eq operand2 :eax))
         (emit-bytes #x3d)
         (emit-raw operand1))
        ((and (reg32-p operand1)
              (consp operand2)
              (length-eql operand2 2)
              (typep (%car operand2) '(signed-byte 8))
              (reg32-p (%cadr operand2)))
         (let* ((reg1 operand1)
                (reg2 (%cadr operand2))
                (displacement-byte (ldb (byte 8 0) (%car operand2)))
                (mod #b01)
                (reg (register-number reg1))
                (rm  (register-number reg2))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #x39 modrm-byte displacement-byte)))
        (t
         (unsupported))))

(define-assembler :cmpl
  (cond ((and (typep operand1 '(unsigned-byte 32))
              (consp operand2)
              (length-eql operand2 2)
              (typep (%car operand2) '(signed-byte 8))
              (reg32-p (%cadr operand2)))
         (let* ((mod #b01)
                (reg 7)
                (rm (register-number (%cadr operand2)))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #x81 modrm-byte (%car operand2))
           (emit-raw operand1)))
        (t
         (unsupported))))

(define-assembler :leave
  (emit-byte #xc9))

(define-assembler :lea
  (cond ((and (consp operand1)
              (length-eql operand1 2)
              (integerp (%car operand1))
              (reg32-p (%cadr operand1))
              (reg32-p operand2))
         (let ((displacement (%car operand1))
               (reg1 (%cadr operand1))
               (reg2 operand2))
           (cond ((typep displacement '(signed-byte 8))
                  (let* ((displacement-byte (ldb (byte 8 0) displacement))
                         (mod #b01)
                         (reg (register-number reg2))
                         (rm  (register-number reg1))
                         (modrm-byte (make-modrm-byte mod reg rm)))
                    (emit-bytes #x8d modrm-byte)
;;                     ;; REVIEW
;;                     (when (memq reg1 '(:rsp :r12))
;;                       (emit-byte #x24))
                    (emit-byte displacement-byte)))
                 (t
                  (unsupported)))))
        (t
         (unsupported))))

(define-assembler :mov
  (cond ((and (reg32-p operand1)
              (reg32-p operand2))
         (let* ((mod #b11)
                (reg (register-number operand1))
                (rm  (register-number operand2))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #x89 modrm-byte)))
        ((and (reg8-p operand1)
              (reg8-p operand2))
         (let* ((mod #b11)
                (reg (register-number operand1))
                (rm  (register-number operand2))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #x88 modrm-byte)))
        ((and (reg32-p operand2)
              (integerp operand1)
              (typep operand1 '(unsigned-byte 32)))
         (emit-byte (+ #xb8 (register-number operand2)))
         (emit-raw operand1))
        ((and (consp operand1)
              (length-eql operand1 1)
              (reg32-p (%car operand1))
              (reg32-p operand2))
         (let* ((reg1 (%car operand1))
                (reg2 operand2)
                (modrm-byte (make-modrm-byte #b00
                                             (register-number reg2)
                                             (register-number reg1))))
           (emit-bytes #x8b modrm-byte)))
        ((and (consp operand1)
              (length-eql operand1 2)
              (integerp (first operand1))
              (reg32-p (second operand1))
              (reg32-p operand2))
         (let ((displacement (first operand1))
               (reg1 (second operand1))
               (reg2 operand2))
           (cond ((zerop displacement)
                  (let ((modrm-byte (make-modrm-byte #b00
                                                     (register-number reg2)
                                                     (register-number reg1))))
                    (emit-bytes #x8b modrm-byte)))
                 ((typep displacement '(signed-byte 8))
                  (let* ((displacement-byte (ldb (byte 8 0) displacement))
                         (mod #b01)
                         (reg (register-number reg2))
                         (rm  (register-number reg1))
                         (modrm-byte (make-modrm-byte mod reg rm)))
                    (emit-bytes #x8b modrm-byte displacement-byte)))
                 (t
                  (let* ((mod #b10)
                         (reg (register-number reg2))
                         (rm  (register-number reg1))
                         (modrm-byte (make-modrm-byte mod reg rm)))
                    (emit-bytes #x8b modrm-byte)
                    (emit-raw displacement))))))
        ((and (consp operand1)
              (length-eql operand1 2)
              (integerp (%car operand1))
              (reg32-p (%cadr operand1))
              (reg8-p operand2))
         (let ((displacement (%car operand1))
               (reg1 (%cadr operand1))
               (reg2 operand2))
           (cond ((typep displacement '(signed-byte 8))
                  (let* ((displacement-byte (ldb (byte 8 0) displacement))
                         (mod #b01)
                         (reg (register-number reg2))
                         (rm  (register-number reg1))
                         (modrm-byte (make-modrm-byte mod reg rm)))
                    (emit-bytes #x8a modrm-byte)
                    (emit-byte displacement-byte)))
                 (t
                  (unsupported)))))
        ((and (consp operand1)
              (length-eql operand1 2)
              (integerp (%car operand1))
              (reg32-p (%cadr operand1))
              (reg16-p operand2))
         (let ((displacement (%car operand1))
               (reg1 (%cadr operand1))
               (reg2 operand2))
           (cond ((typep displacement '(signed-byte 8))
                  (let* ((displacement-byte (ldb (byte 8 0) displacement))
                         (mod #b01)
                         (reg (register-number reg2))
                         (rm  (register-number reg1))
                         (modrm-byte (make-modrm-byte mod reg rm)))
                    (emit-bytes #x66 #x8b modrm-byte)
                    ;;                            ;; REVIEW
                    ;;                            (when (memq reg1 '(:rsp :r12))
                    ;;                              (emit-byte #x24))
                    (emit-byte displacement-byte)))
                 (t
                  (unsupported)))))
        ((and (consp operand1)
              (length-eql operand1 4)
              (reg32-p operand2))
         (with-address-operand operand1
           (cond ((and displacement (typep displacement '(signed-byte 8)))
                  (let* ((displacement-byte (ldb (byte 8 0) displacement))
                         (reg (register-number operand2))
                         (rm  #b100)
                         (modrm-byte (make-modrm-byte #b01 reg rm))
                         (sib-byte (make-sib-byte scale
                                                  (register-number index)
                                                  (register-number base))))
                    (emit-bytes #x8b modrm-byte sib-byte displacement-byte)))
                 (t
                  (unsupported)))))
        ((consp operand2)
         (cond ((and (length-eql operand2 2)
                     (integerp (first operand2))
                     (eq (second operand2) :esp)
                     (reg32-p operand1))
                (let ((reg1 operand1)
                      (displacement (first operand2))
                      (reg2 (second operand2)))
                  (cond ((zerop displacement)
                         (let* ((mod #b00)
                                (reg (register-number reg1))
                                (rm  (register-number reg2))
                                (modrm-byte (make-modrm-byte mod reg rm)))
                           (emit-bytes #x89 modrm-byte #x24)))
                        ((typep displacement '(signed-byte 8))
                         (let* ((mod #b01)
                                (reg (register-number reg1))
                                (rm  (register-number reg2))
                                (modrm-byte (make-modrm-byte mod reg rm)))
                           (emit-bytes #x89 modrm-byte #x24 (ldb (byte 8 0) displacement))))
                        (t
                         (let* ((mod #b10)
                                (reg (register-number reg1))
                                (rm  (register-number reg2))
                                (modrm-byte (make-modrm-byte mod reg rm)))
                           (emit-bytes #x89 modrm-byte #x24)
                           (emit-raw displacement))))))
               ((and (length-eql operand2 2)
                     (integerp (first operand2))
                     (reg32-p (second operand2))
                     (reg32-p operand1))
                (let ((reg1 operand1)
                      (displacement (first operand2))
                      (reg2 (second operand2)))
                  (cond ((zerop displacement)
                         (let* ((mod #b00)
                                (reg (register-number reg1))
                                (rm  (register-number reg2))
                                (modrm-byte (make-modrm-byte mod reg rm)))
                           (emit-bytes #x89 modrm-byte)))
                        ((typep displacement '(signed-byte 8))
                         (let* ((displacement-byte (ldb (byte 8 0) displacement))
                                (mod #b01)
                                (reg (register-number reg1))
                                (rm  (register-number reg2))
                                (modrm-byte (make-modrm-byte mod reg rm)))
                           (emit-bytes #x89 modrm-byte displacement-byte)))
                        (t
                         (let* ((mod #b10)
                                (reg (register-number reg1))
                                (rm  (register-number reg2))
                                (modrm-byte (make-modrm-byte mod reg rm)))
                           (emit-bytes #x89 modrm-byte)
                           (emit-raw displacement))))))
               ((and (length-eql operand2 1)
                     (reg32-p operand1)
                     (reg32-p (%car operand2)))
                (let* ((reg1 operand1)
                       (reg2 (%car operand2))
                       (modrm-byte (make-modrm-byte #b00
                                                    (register-number reg1)
                                                    (register-number reg2))))
                  (emit-bytes #x89 modrm-byte)
                  (when (eq reg2 :esp)
                    (emit-byte #x24))))
               ((and (length-eql operand2 1)
                     (reg32-p (%car operand2))
                     (reg8-p operand1))
                (let* ((reg1 operand1)
                       (reg2 (%car operand2))
                       (modrm-byte (make-modrm-byte #b00
                                                    (register-number reg1)
                                                    (register-number reg2))))
                  (emit-bytes #x88 modrm-byte)))
               (t
                (unsupported))))
        (t
         (unsupported))))

(define-assembler :movb
  (cond ((and (typep operand1 '(unsigned-byte 8))
              (consp operand2)
              (length-eql operand2 2)
              (integerp (first operand2))
              (reg32-p (second operand2)))
         (let* ((mod #b01)
                (reg 0)
                (rm (register-number (second operand2)))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #xc6 modrm-byte (first operand2) operand1)))
        ((and (consp operand1)
              (length-eql operand1 2)
              (integerp (%car operand1))
              (reg32-p (%cadr operand1))
              (reg8-p operand2))
         (let ((displacement (%car operand1))
               (reg1 (%cadr operand1))
               (reg2 operand2))
           (cond ((typep displacement '(signed-byte 8))
                  (let* ((displacement-byte (ldb (byte 8 0) displacement))
                         (mod #b01)
                         (reg (register-number reg2))
                         (rm  (register-number reg1))
                         (modrm-byte (make-modrm-byte mod reg rm)))
                    (emit-bytes #x8a modrm-byte)
;;                     ;; REVIEW
;;                     (when (memq reg1 '(:rsp :r12))
;;                       (emit-byte #x24))
                    (emit-byte displacement-byte)))
                 (t
                  (unsupported)))))
        (t
         (unsupported))))

(define-assembler :movzbl
  (cond ((and (reg8-p operand1)
              (reg32-p operand2))
         (let* ((mod #b11)
                (reg (register-number operand2))
                (rm  (register-number operand1))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #x0f #xb6 modrm-byte)))
        ((address-operand-p operand1)
         (with-address-operand operand1
           (cond ((and displacement (typep displacement '(signed-byte 8)))
                  (let* ((displacement-byte (ldb (byte 8 0) displacement))
                         (reg (register-number operand2))
                         (rm #b100)
                         (modrm-byte (make-modrm-byte #b01 reg rm))
                         (sib-byte (make-sib-byte scale (register-number index) (register-number base))))
                    (emit-bytes #x0f #xb6 modrm-byte sib-byte displacement-byte)))
                 (t
                  (unsupported)))))
        (t
         (unsupported))))

(define-assembler :movzwl
  (cond ((address-operand-p operand1)
         (with-address-operand operand1
           (cond ((and displacement (typep displacement '(unsigned-byte 8)))
                  (let* ((displacement-byte (ldb (byte 8 0) displacement))
                         (reg (register-number operand2))
                         (rm #b100)
                         (modrm-byte (make-modrm-byte #b01 reg rm))
                         (sib-byte (make-sib-byte scale (register-number index) (register-number base))))
                    (emit-bytes #x0f #xb7 modrm-byte sib-byte displacement-byte)))
                 (t
                  (unsupported)))))
        (t
         (unsupported))))

(define-assembler :neg
  (cond ((reg32-p operand1)
         (let* ((mod #b11)
                (reg 3)
                (rm  (register-number operand1))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #xf7 modrm-byte)))
        (t
         (unsupported))))

(define-assembler :pop
  (cond ((reg32-p operand1)
         (emit-byte (+ (register-number operand1) #x58)))
        ((and (consp operand1)
              (length-eql operand1 2)
              (typep (%car operand1) '(signed-byte 8))
              (reg32-p (%cadr operand1)))
         (let* ((mod #b01)
                (reg 0)
                (rm (register-number (%cadr operand1)))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #x8f modrm-byte (ldb (byte 8 0) (%car operand1)))))
        ((and (consp operand1)
              (length-eql operand1 1)
              (reg32-p (%car operand1)))
         (let* ((mod #b00)
                (reg 0)
                (rm (register-number (%car operand1)))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #x8f modrm-byte)))))

(define-assembler :push
  (cond ((reg32-p operand1)
         (emit-byte (+ (register-number operand1) #x50)))
        ((typep operand1 '(signed-byte 8))
         (emit-bytes #x6a (ldb (byte 8 0) operand1)))
        ((typep operand1 '(signed-byte 32))
         (emit-byte #x68)
         (emit-raw operand1))
        ((and (consp operand1)
              (typep (car operand1) '(signed-byte 8))
              (reg32-p (cadr operand1)))
         (let* ((mod #b01)
                (reg 6)
                (rm (register-number (cadr operand1)))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #xff modrm-byte (ldb (byte 8 0) (car operand1)))))
        ((and (consp operand1)
              (typep (car operand1) '(signed-byte 32))
              (reg32-p (cadr operand1)))
         (let* ((mod #b10)
                (reg 6)
                (rm (register-number (cadr operand1)))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #xff modrm-byte)
           (emit-raw (car operand1))))
        (t
         (unsupported))))

(define-assembler :sar
  (cond ((and (typep operand1 '(unsigned-byte 8))
              (reg32-p operand2))
         (let ((modrm-byte (make-modrm-byte #b11 7 (register-number operand2))))
           (emit-bytes #xc1 modrm-byte operand1)))
        ((and (eq operand1 :cl)
              (reg32-p operand2))
         (let ((modrm-byte (make-modrm-byte #b11 7 (register-number operand2))))
           (emit-bytes #xd3 modrm-byte)))
        (t
         (unsupported))))

(define-assembler :setb
  (cond ((and (reg8-p operand1)
              (null operand2))
         (let ((modrm-byte (make-modrm-byte #b11 0 (register-number operand1))))
           (emit-bytes #x0f #x92 modrm-byte)))
        (t
         (unsupported))))

(define-assembler :shl
  (cond ((and (null operand2)
              (reg32-p operand1))
         (let ((modrm-byte (make-modrm-byte #b11 4 (register-number operand1))))
           (emit-bytes #xd1 modrm-byte)))
        ((and (typep operand1 '(unsigned-byte 8))
              (reg32-p operand2))
         (let ((modrm-byte (make-modrm-byte #b11 4 (register-number operand2))))
           (emit-bytes #xc1 modrm-byte operand1)))
        (t
         (unsupported))))

(define-assembler :shr
  (cond ((and (typep operand1 '(unsigned-byte 8))
              (reg32-p operand2))
         (let ((modrm-byte (make-modrm-byte #b11 5 (register-number operand2))))
           (emit-bytes #xc1 modrm-byte operand1)))
        (t
         (unsupported))))

(define-assembler :sub
  (cond ((and (integerp operand1)
              (reg32-p operand2))
         (cond ((typep operand1 '(signed-byte 8))
                (let ((modrm-byte (make-modrm-byte #b11 5 (register-number operand2))))
                  (emit-bytes #x83 modrm-byte (ldb (byte 8 0) operand1))))
               ((typep operand1 '(signed-byte 32))
                (let ((modrm-byte (make-modrm-byte #b11 5 (register-number operand2))))
                  (emit-bytes #x81 modrm-byte)
                  (emit-raw-dword operand1)))
               (t
                (unsupported))))
        ((and (reg32-p operand1)
              (reg32-p operand2))
         (let* ((mod #b11)
                (reg (register-number operand1))
                (rm  (register-number operand2))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #x29 modrm-byte)))
        (t
         (unsupported))))

(define-assembler :ret
  (emit-byte #xc3))

(define-assembler :test
  (cond ((and (reg32-p operand1)
              (reg32-p operand2))
         (let* ((mod #b11)
                (reg (register-number operand1))
                (rm  (register-number operand2))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #x85 modrm-byte)))
        ((and (reg8-p operand1)
              (reg8-p operand2))
         (let* ((mod #b11)
                (reg (register-number operand1))
                (rm  (register-number operand2))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #x84 modrm-byte)))
        ((and (typep operand1 '(unsigned-byte 8))
              (eq operand2 :al))
         (emit-bytes #xa8 operand1))
        ((and (typep operand1 '(unsigned-byte 8))
              (memq operand2 '(:bl :cl :dl)))
         (let ((modrm-byte (make-modrm-byte #b11 0 (register-number operand2))))
           (emit-bytes #xf6 modrm-byte operand1)))
        (t
         (unsupported))))

(define-assembler :testl
  (cond ((and (typep operand1 '(unsigned-byte 32))
              (consp operand2)
              (length-eql operand2 2)
              (typep (%car operand2) '(signed-byte 8))
              (reg32-p (%cadr operand2)))
         (let* ((mod #b01)
                (reg 0)
                (rm (register-number (%cadr operand2)))
                (modrm-byte (make-modrm-byte mod reg rm)))
           (emit-bytes #xf7 modrm-byte (%car operand2))
           (emit-raw operand1)))
        (t
         (unsupported))))

(define-assembler :xor
  (cond ((and (reg32-p operand1)
              (reg32-p operand2))
         (let ((modrm-byte (make-modrm-byte #b11
                                            (register-number operand1)
                                            (register-number operand2))))
           (emit-bytes #x31 modrm-byte)))
        (t
         (unsupported))))
