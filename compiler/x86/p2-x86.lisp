;;; p2-x86.lisp
;;;
;;; Copyright (C) 2006-2011 Peter Graves <gnooth@gmail.com>
;;;
;;; This program is free software; you can redistribute it and/or
;;; modify it under the terms of the GNU General Public License
;;; as published by the Free Software Foundation; either version 2
;;; of the License, or (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

(in-package "COMPILER")

(defknown emit-call-n (t t t) t)
(defun emit-call-n (address target n)
  (emit-call address)
  (unless (and (eq target :return)
               (not (compiland-omit-frame-pointer *current-compiland*)))
    (emit-adjust-stack-after-call n))
  (move-result-to-target target))

(defknown emit-call-0 (t t) t)
(defun emit-call-0 (address target)
  (emit-call-n address target 0))

(defknown emit-call-1 (t t) t)
(defun emit-call-1 (address target)
  (emit-call-n address target 1))

(defknown emit-call-2 (t t) t)
(defun emit-call-2 (address target)
  (emit-call-n address target 2))

(defknown emit-call-3 (t t) t)
(defun emit-call-3 (address target)
  (emit-call-n address target 3))

(defknown emit-call-4 (t t) t)
(defun emit-call-4 (address target)
  (emit-call-n address target 4))

(defknown emit-call-5 (t t) t)
(defun emit-call-5 (address target)
  (emit-call-n address target 5))

(defknown emit-call-6 (t t) t)
(defun emit-call-6 (address target)
  (emit-call-n address target 6))

(defknown emit-call-7 (t t) t)
(defun emit-call-7 (address target)
  (emit-call-n address target 7))

(defknown emit-call-8 (t t) t)
(defun emit-call-8 (address target)
  (emit-call-n address target 8))

(defknown emit-clear-values (*) t)
(defun emit-clear-values (&key preserve)
  (setq preserve (if (eq preserve :stack)
                     nil
                     (designator-list preserve)))
  (when (memq :return preserve)
    (mumble "emit-clear-values: found :RETURN on preserve list~%")
    (setq preserve (substitute :return :eax preserve)))
  (let ((thread-var (compiland-thread-var *current-compiland*)))
    (cond (thread-var
           (let ((reg (cond ((not (memq :eax preserve))
                             :eax)
                            ((not (memq :edx preserve))
                             :edx)
                            ((not (memq :ecx preserve))
                             :ecx)
                            (t
                             ;; FIXME
                             (aver nil)))))
             (inst :mov thread-var reg)
             (clear-register-contents reg)
             (inst :movb #xff `(,+values-length-offset+ ,reg))))
          (t
           (note "EMIT-CLEAR-VALUES: emitting call to RT_current_thread_clear_values~%")
           (dolist (reg preserve)
             (unless (eq reg :stack)
               (inst :push reg)))
           (emit-call "RT_current_thread_clear_values")
           (dolist (reg (reverse preserve))
             (unless (eq reg :stack)
               (inst :pop reg)))))))

(defknown allocate-locals (t t) t)
(defun allocate-locals (compiland index)
  (declare (type compiland compiland))
  (declare (type fixnum index))
  (when (compiland-needs-thread-var-p compiland)
    (push (compiland-thread-var compiland) *local-variables*)
    (push (compiland-thread-var compiland) (compiland-local-vars compiland)))
  (let ((locals (reverse *local-variables*)))
    (when locals
      (dolist (var locals)
        (declare (type var var))
        (unless (var-special-p var)
          (when (eq (var-compiland-id var) (compiland-id compiland))
;;             (aver (null (var-index var)))
            (unless (or (var-register var) (var-closure-index var))
              (setf (var-index var) index)
              (decf index)))))
      (let* ((numvars (let ((count 0))
                        (dolist (var locals count)
                          (declare (type var var))
                          ;; We don't need to allocate space on the stack for
                          ;; closure vars or specials.
                          (unless (or (var-special-p var)
                                      (var-closure-index var))
                            (incf count)))))
             (numbytes (* numvars +bytes-per-word+)))
        (cond ((zerop numbytes)
               ; nothing to do
               )
              ((< numbytes 128)
               (inst :sub numbytes :esp)
               )
              (t
               (inst :sub numbytes :esp)))))))

(defknown trivial-allocate-locals (t) t)
(defun trivial-allocate-locals (compiland)
  (let ((locals (reverse *local-variables*)))
    (when locals
      (dolist (var locals)
        (declare (type var var))
        (unless (var-special-p var)
          (when (eq (var-compiland-id var) (compiland-id compiland))
;;             (aver (null (var-index var)))
            (aver (null (var-register var)))
            (aver (null (var-closure-index var)))
            (inst :allocate-local var)))))))

(defknown p2-trivial-function-prolog (compiland) t)
(defun p2-trivial-function-prolog (compiland)
  (declare (type compiland compiland))
  (clear-register-contents)
  (inst :save-registers)
  (inst :enter-frame)

;;   (trivial-allocate-locals compiland)
  (inst :allocate-thread-var)
  (inst :allocate-locals)

  (inst :align-stack)
  (inst :initialize-thread-var)
  (clear-register-contents)
  t)

(defknown p2-child-function-prolog (compiland) t)
(defun p2-child-function-prolog (compiland)
  (declare (type compiland compiland))
  (aver (and *closure-vars* (compiland-child-p compiland)))
  (let ((index 2)) ; first arg is at 8(%ebp)
    (aver (eq compiland *current-compiland*))
    (setf (compiland-closure-data-index compiland) index)
    (incf index)
    (dolist (var (compiland-arg-vars compiland))
      (declare (type var var))
      (when (fixnump (var-index var))
        (incf (var-index var)))))

  ;; REVIEW (or t ...)
  (cond ((or t (compiland-arg-vars compiland) *local-variables* *closure-vars*)
         (inst :push :ebp)
         (emit-bytes #x89 #xe5)) ; mov %esp,%ebp
        (t
         (setf (compiland-omit-frame-pointer compiland) t)))

  (let* ((arity (compiland-arity compiland))
         (closure-data-index (compiland-closure-data-index compiland))
         ;; if arity is not fixed or is > 6, the next two arguments will be
         ;; (1) the number of actual arguments:
         (numargs-index (unless (and (fixnump arity) (<= arity 6))
                          (+ closure-data-index 1)))
         ;; and (2) the argument vector:
         (argument-vector-index (unless (and (fixnump arity) (<= arity 6))
                                  (+ closure-data-index 2)))
         ;; first local is at -4(%ebp)
         (index -1))

    (aver (eql closure-data-index 2))
    (unless arity
      (aver (eql numargs-index 3))
      (aver (eql argument-vector-index 4)))

    (when (some 'var-used-non-locally-p (compiland-arg-vars compiland))
      (mumble "p2-child-function-prolog: at least one arg-var is used non-locally~%")
      (inst :push (length *closure-vars*))
      (inst :push `(,(index-displacement closure-data-index) :ebp))
      (emit-call-2 "RT_copy_closure_data_vector" :eax) ; returns copy of data vector in eax
      (inst :mov :eax `(,(index-displacement closure-data-index) :ebp)))

    (dolist (var (compiland-arg-vars compiland))
      (declare (type var var))
      (when (var-used-non-locally-p var)
        (aver (fixnump (var-closure-index var)))
        (when (var-index var)
          ;; each new binding gets a new value cell
          (emit-move-local-to-register (var-index var) :eax)
          (inst :push :eax)
          (setf (var-index var) nil)
          (emit-call-1 "RT_make_value_cell_1" :eax)
          (emit-move-local-to-register closure-data-index :edx)
          (inst :mov :eax `(,(* (var-closure-index var) +bytes-per-word+) :edx)))))

    (let ((lambda-list (cadr (compiland-lambda-expression compiland))))
      (cond ((or (memq '&optional lambda-list)
                 (memq '&key lambda-list))

             (let* ((names (lambda-list-names lambda-list))
                    (n (length names))
                    (numbytes (* n +bytes-per-word+)))
               (inst :sub numbytes :esp)
               (inst :push :esp)
               (decf index n))

             (let ((prototype (coerce-to-function (list 'LAMBDA lambda-list nil))))
               (inst :push-immediate `(:constant ,prototype)))
             (emit-move-local-to-register argument-vector-index :eax) ; argument vector
             (inst :push :eax)
             (emit-move-local-to-register numargs-index :eax) ; numargs
             (inst :push :eax)
             (emit-call-4 "RT_process_args" :eax)

             ;; address of processed argument vector is now in eax
             (when (some #'var-used-non-locally-p (compiland-arg-vars compiland))
               (inst :mov :eax :ecx))
             (let ((base (1+ index)))
               (dolist (var (compiland-arg-vars compiland))
                 (declare (type var var))
                 ;; FIXME call-arguments-limit
                 (cond ((var-used-non-locally-p var)
                        (aver (fixnump (var-arg-index var)))
                        (aver (fixnump (var-closure-index var)))
                        (emit-move-relative-to-register :ecx (var-arg-index var) :eax)
                        (inst :push :ecx)
                        (emit-move-register-to-closure-var :eax var compiland)
                        (inst :pop :ecx))
                       (t
                        (aver (var-arg-index var))
                        (aver (null (var-index var)))
                        (aver (null (var-closure-index var)))
                        (setf (var-index var) (+ base (var-arg-index var))))))))
            ((null (compiland-arity compiland))
             ;; restvar case, with or without required args
             (when (dolist (var (compiland-arg-vars compiland))
                     (when (eq (var-kind var) :required)
                       (return t)))
               ;; at least one required arg
               (emit-move-local-to-register argument-vector-index :ecx)) ; argument vector
             ;; emit code to move arguments from argument vector to their permanent locations
             (dolist (var (compiland-arg-vars compiland))
               (declare (type var var))
               (case (var-kind var)
                 (:required
                  (aver (var-arg-index var))
                  (aver (null (var-index var)))
                  (emit-move-relative-to-register :ecx (var-arg-index var) :eax)
                  (cond ((var-closure-index var)
                         (inst :push :ecx)
                         (emit-move-register-to-closure-var :eax var compiland)
                         (inst :pop :ecx))
                        (t
                         (setf (var-index var) index)
                         (decf index)
                         (inst :push :eax))))
                 (:rest
                  (aver (null (var-index var)))
                  (cond ((var-closure-index var)
                         ; nothing to do
                         (aver (fixnump (var-closure-index var))))
                        (t
                         ;; reserve space for rest var
                         (inst :push :eax)
                         (setf (var-index var) index)
                         (decf index))))
                 (t
                  (compiler-unsupported "P2-CHILD-FUNCTION-PROLOG unsupported var-kind ~S" (var-kind var)))))
             (let ((start 0)
                   (restvar nil))
               (dolist (var (compiland-arg-vars compiland))
                 (declare (type var var))
                 (case (var-kind var)
                   (:required
                    (incf start))
                   (:rest
                    (setq restvar var)
                    (aver (or (var-index restvar) (var-closure-index restvar)))
                    (return))))
               (emit-move-local-to-register numargs-index :eax) ; numargs (end index)
               (inst :push :eax)
               (inst :push start) ; start index
               (emit-move-local-to-register argument-vector-index :eax) ; argument vector
               (inst :push :eax)
               (emit-call-3 "RT_restify" :eax)
               (cond ((var-closure-index restvar)
                      (mumble "P2-CHILD-FUNCTION-PROLOG (var-closure-index restvar) case~%")
                      (emit-move-register-to-closure-var :eax restvar compiland))
                     (t
                      (inst :mov :eax restvar)))))
            ((> arity 6)
             (emit-move-local-to-register argument-vector-index :ecx) ; argument vector
             ;; emit code to move compiland-arg-vars from arg vector to their permanent locations
             (dolist (var (compiland-arg-vars compiland))
               (declare (type var var))
               (when (var-closure-index var)
                 (compiler-unsupported "P2-CHILD-FUNCTION-PROLOG arity > 6, var closure index case~%"))
               (ecase (var-kind var)
                 (:required
                  (aver (var-arg-index var))
                  (aver (null (var-index var)))
                  (aver (null (var-closure-index var)))
                  (emit-move-relative-to-register :ecx (var-arg-index var) :eax)
                  (inst :push :eax)
                  (setf (var-index var) index)
                  (decf index))
                 (:rest
                  (aver (null (var-index var)))
                  (aver (null (var-closure-index var)))
                  ;; initialize rest var to zero for the moment
                  (inst :xor :eax :eax)
                  (inst :push :eax)
                  (setf (var-index var) index)
                  (decf index)))))))
    (allocate-locals compiland index))
  (when (compiland-thread-var compiland)
    (emit-call "RT_current_thread")
    (inst :mov :eax (compiland-thread-var compiland)))
  t)

(defun allocate-closure-data-vector (numvars)
  (inst :push (* numvars +bytes-per-word+))
  (emit-call-1 "RT_allocate_closure_data_vector" :eax))

(defun p2-function-prolog (compiland)
  (declare (type compiland compiland))
  (let ((arity (compiland-arity compiland)))
    (when (and arity
               (<= arity 6)
               (null *closure-vars*))
;;       (return-from p2-function-prolog (p2-trivial-function-prolog compiland))
      (return-from p2-function-prolog t)
      ))

  (when (and *closure-vars* (compiland-child-p compiland))
    (return-from p2-function-prolog (p2-child-function-prolog compiland)))

  ;; REVIEW (or t ...)
  (cond ((or t (compiland-arg-vars compiland) *local-variables* *closure-vars*)
         (inst :push :ebp)
         (inst :mov :esp :ebp))
        (t
         (setf (compiland-omit-frame-pointer compiland) t)))

  (let ((index -1)) ; first local is at -4(%ebp)
    (when (and *closure-vars* (null (compiland-parent compiland))) ; top-level compiland
;;       (inst :push (* (length *closure-vars*) +bytes-per-word+))
;;       (emit-call-1 "RT_malloc" :stack) ; the first local is the closure variable vector
      (allocate-closure-data-vector (length *closure-vars*)) ; leaves address in eax
      ; the first local is the closure variable vector
      (inst :push :eax)
      (setf (compiland-closure-data-index compiland) index)
      (decf index)
      (dolist (var (compiland-arg-vars compiland))
        (declare (type var var))
        (when (var-used-non-locally-p var)
          (aver (fixnump (var-closure-index var)))
          (when (var-index var)
            (emit-move-local-to-register (var-index var) :eax)
            (setf (var-index var) nil)
            (emit-move-register-to-closure-var :eax var compiland)))))

    (let ((lambda-list (cadr (compiland-lambda-expression compiland))))
      (cond ((or (memq '&optional lambda-list)
                 (memq '&key lambda-list)
                 (and (compiland-arity compiland)
                      (> (compiland-arity compiland) 6)))

             (let* ((names (lambda-list-names lambda-list))
                    (n (length names))
                    (numbytes (* n +bytes-per-word+)))
               (inst :sub numbytes :esp)
               (inst :push :esp)
               (decf index n))

             (let ((prototype (coerce-to-function (list 'LAMBDA lambda-list nil))))
               (inst :push-immediate `(:constant ,prototype)))
             (inst :push '(12 :ebp)) ; args
             (inst :push '(8 :ebp)) ; numargs
             (emit-call-4 "RT_process_args" :eax)
             ;; address of args array is now in eax
             (when (some #'var-used-non-locally-p (compiland-arg-vars compiland))
               (inst :mov :eax :ecx))
             ;; address of args array is now in ecx
             (let ((base (1+ index)))
               (dolist (var (compiland-arg-vars compiland))
                 (declare (type var var))
                 ;; FIXME call-arguments-limit
                 (cond ((var-used-non-locally-p var)
                        (aver (fixnump (var-arg-index var)))
                        (aver (fixnump (var-closure-index var)))
                        (emit-move-relative-to-register :ecx (var-arg-index var) :eax)
                        (inst :push :ecx)
                        (emit-move-register-to-closure-var :eax var compiland)
                        (inst :pop :ecx))
                       (t
                        (aver (var-arg-index var))
;;                         (aver (null (var-index var)))
                        (aver (null (var-closure-index var)))
                        (setf (var-index var) (+ base (var-arg-index var))))))))
            ((null (compiland-arity compiland))
             ;; restvar case, with or without required args
             (when (dolist (var (compiland-arg-vars compiland))
                     (when (eq (var-kind var) :required)
                       (return t)))
               ;; at least one required arg
               (emit-move-local-to-register 3 :ecx)) ; argument vector
             ;; emit code to move arguments from argument vector to their permanent locations
             (dolist (var (compiland-arg-vars compiland))
               (declare (type var var))
               (case (var-kind var)
                 (:required
                  (aver (var-arg-index var))
;;                   (aver (null (var-index var)))
                  (emit-move-relative-to-register :ecx (var-arg-index var) :eax)
                  (cond ((var-closure-index var)
                         (inst :push :ecx)
                         (emit-move-register-to-closure-var :eax var compiland)
                         (inst :pop :ecx))
                        (t
                         (setf (var-index var) index)
                         (decf index)
                         (inst :push :eax))))
                 (:rest
;;                   (aver (null (var-index var)))
                  (cond ((var-closure-index var)
                         ; nothing to do
                         (aver (fixnump (var-closure-index var))))
                        (t
                         ;; reserve space for rest var
                         (inst :push :eax)
                         (setf (var-index var) index)
                         (decf index))))
                 (t
                  (compiler-unsupported "P2-FUNCTION-PROLOG unsupported var-kind ~S" (var-kind var)))))
             (let ((start 0)
                   (restvar nil))
               (dolist (var (compiland-arg-vars compiland))
                 (declare (type var var))
                 (case (var-kind var)
                   (:required
                    (incf start))
                   (:rest
                    (setq restvar var)
                    (aver (or (var-index restvar) (var-closure-index restvar)))
                    (return))))
               (emit-move-local-to-register 2 :eax) ; numargs (end index)
               (inst :push :eax)
               (inst :push start) ; start index
               (emit-move-local-to-register 3 :eax) ; argument vector
               (inst :push :eax)
               (emit-call-3 "RT_restify" :eax)
               (cond ((var-closure-index restvar)
                      (emit-move-register-to-closure-var :eax restvar compiland))
                     (t
                      (inst :mov :eax restvar)))))))
    (allocate-locals compiland index))
  (when (compiland-thread-var compiland)
    (emit-call "RT_current_thread")
    (inst :mov :eax (compiland-thread-var compiland))))

;; index-displacement index => displacement
(defknown index-displacement (t) t)
(declaim (inline index-displacement))
(defun index-displacement (index)
  (* index +bytes-per-word+))

(defknown emit-move-local-to-register (t t) t)
(defun emit-move-local-to-register (index to)
  (let ((displacement (index-displacement index)))
    (inst :mov `(,displacement :ebp) to)))

(defknown %emit-move-relative-to-register (t t t) t)
(defun %emit-move-relative-to-register (from-reg displacement to-reg)
  (inst :mov `(,displacement ,from-reg) to-reg))

(defknown emit-move-relative-to-register (t t t) t)
(defun emit-move-relative-to-register (from-reg index to-reg)
  (%emit-move-relative-to-register from-reg (index-displacement index) to-reg))

(defknown %emit-move-register-to-relative (t t t) t)
(defun %emit-move-register-to-relative (from-reg to-reg displacement)
  (inst :mov from-reg `(,displacement ,to-reg)))

(defknown emit-move-register-to-relative (t t t) t)
(defun emit-move-register-to-relative (from-reg to-reg index)
  (let ((displacement (index-displacement index)))
    (inst :mov from-reg `(,displacement ,to-reg))))

(defun emit-dword (n)
  (let ((x (value-to-ub32 n)))
    (let ((code (list (ldb (byte 8 0) x)
                      (ldb (byte 8 8) x)
                      (ldb (byte 8 16) x)
                      (ldb (byte 8 24) x))))
;;       (emit (list* :bytes code))
      (emit (make-ir2-instruction :bytes code nil))
      )))

(defun emit-raw (x)
  (let ((code (list (ldb (byte 8 0) x)
                    (ldb (byte 8 8) x)
                    (ldb (byte 8 16) x)
                    (ldb (byte 8 24) x))))
;;     (emit (list* :bytes code))
    (emit (make-ir2-instruction :bytes code nil))
    ))

(defun emit-move-immediate (n target)
  (when (eq target :return)
    (setq target :eax))
  (cond ((reg32-p target)
         (inst :mov (value-to-ub32 n) target))
        (t
         (compiler-unsupported "EMIT-MOVE-IMMEDIATE unsupported target ~S" target))))

(defknown emit-push-immediate (t) t)
(defun emit-push-immediate (arg)
  (when (fixnump arg)
    (let ((n (value-to-ub32 arg)))
      (when (< n 128)
        (emit-byte #x6a) ; push immediate byte
        (emit-byte n)
        (return-from emit-push-immediate))))
  (emit-byte #x68)
  (emit-dword arg))

(defknown move-result-to-target (t) t)
(defun move-result-to-target (target)
  (case target
    ((:eax nil)
     ;; nothing to do
     )
    ((:ecx :edx :ebx :esp :ebp :esi :edi)
     (inst :mov :eax target)
     (clear-register-contents target))
    (:stack
     (inst :push :eax))
    (:return
     (inst :exit))
    (t
     (compiler-unsupported "MOVE-RESULT-TO-TARGET target = ~S" target))))

(defknown emit-adjust-stack-after-call (t) t)
(defun emit-adjust-stack-after-call (n)
  (aver (not (minusp n)))
  (cond ((eql n 0)) ; nothing to do
        #+nil
        ((eql n 1)
         (inst :pop :edx)
         (clear-register-contents))
        #+nil
        ((eql n 2)
         (inst :pop :edx)
         (inst :pop :edx)
         (clear-register-contents)
         )
        ((< n 32)
         (inst :add (* n +bytes-per-word+) :esp))
        (t
         (compiler-unsupported "EMIT-ADJUST-STACK-AFTER-CALL n = ~D" n))))

(defknown emit-move-function-to-register (t t) t)
(defun emit-move-function-to-register (symbol register)
  (inst :move-immediate `(:function ,symbol) register))

(defknown p2-constant (t t) t)
(defun p2-constant (form target)
  (cond ((or (fixnump form)
             (characterp form))
         (case target
           ((nil)) ; nothing to do
           (:stack
            (emit-push-immediate form))
           ((:eax :ecx :edx :ebx :esp :ebp :esi :edi)
            (cond ((eql form 0)
                   (inst :xor target target))
                  (t
                   (emit-move-immediate form target)
;;                    (inst :mov form target)
                   ))
            (clear-register-contents target))
           (:return
            (if (eql form 0)
                (inst :xor :eax :eax)
                (emit-move-immediate form :eax)
;;                 (inst :mov form :eax)
                )
            (inst :exit))
           (t
            (compiler-unsupported "P2-CONSTANT unsupported situation 1"))))
        ((or (numberp form)
             (symbolp form)
             (arrayp form)
             (listp form)
             (characterp form)
             (hash-table-p form)
             (packagep form)
             (functionp form) ; REVIEW
             )
         (cond ((null target)
                ; nothing to do
                )
               ((eq target :stack)
                (inst :push (list :constant form)))
               ((reg32-p target)
                (inst :move-immediate (list :constant form) target)
                (clear-register-contents target))
               ((eq target :return)
                (inst :move-immediate (list :constant form) :eax)
                (clear-register-contents :eax)
                (inst :exit))
               (t
                (compiler-unsupported "P2-CONSTANT unsupported situation 2")))
         )
        (t
         (compiler-unsupported "P2-CONSTANT unsupported situation 3 type-of form = ~S"
                               (type-of form)))))

(defun p2-load-time-value (form target)
  (mumble "p2-load-time-value~%")
  (cond ((compile-file-p)
         (let* ((name (gensym)))
           (dump-top-level-form `(defvar ,name ,(cadr form)) *compile-file-output-stream*)
           (p2-constant name :stack)
           (emit-call-1 'symbol-global-value target)))
        (t
         (p2-constant (eval (cadr form)) target))))

(defun p2-block (form target)
  (let* ((block (cadr form))
         (block-var (block-block-var block))
         (last-special-binding-var (block-last-special-binding-var block))
         (*visible-blocks* (cons block *visible-blocks*))
         (BLOCK-EXIT (make-label))
         (LABEL1 (make-label))
         (compiland *current-compiland*)
         (thread-var (compiland-thread-var compiland)))
    (declare (type cblock block))
    (declare (type compiland compiland))
    (when last-special-binding-var
      (aver thread-var)
      (inst :push thread-var)
      (emit-call-1 "RT_thread_last_special_binding" :eax)
      (inst :mov :eax last-special-binding-var))
    (setf (block-exit block) BLOCK-EXIT)
    (setf (block-target block) target)
    (cond ((block-non-local-return-p block)
           (aver block-var)
           (aver thread-var)
           (p2-symbol (block-name block) :stack)
           (inst :push thread-var)
           (emit-call-2 "RT_enter_block" :eax)
           (inst :mov :eax block-var)
           (inst :push :eax)
           (emit-call-1 "RT_frame_jmp" :stack)
           (emit-call-1 "setjmp" :eax)
           (inst :test :eax :eax)
           (emit-jmp-short :nz LABEL1)
           (p2-progn-body (block-body block) :eax)
           (emit-jmp-short t BLOCK-EXIT)
           (label LABEL1)
           (inst :push block-var)
           (inst :push thread-var)
           (emit-call-2 "RT_block_non_local_return" :eax))
          (t
           (p2-progn-body (block-body block) :eax)))
    (label BLOCK-EXIT)
    (when (block-non-local-return-p block)
      (inst :push :eax) ; save result
      (inst :push block-var)
      (inst :push thread-var)
      (emit-call-2 "RT_leave_block" nil)
      (inst :pop :eax)) ; restore result
    (when last-special-binding-var
      ;; save result
      (inst :push :eax)
      ;; restore last special binding
      (aver thread-var)
      (inst :push last-special-binding-var)
      (inst :push thread-var)
      (emit-call-2 "RT_thread_set_last_special_binding" nil)
      ;; restore result
      (inst :pop :eax))
    (move-result-to-target target)))

(defun p2-return-from (form target)
  (declare (ignore target))
  (let* ((name (second form))
         (result-form (third form))
         (block (find-visible-block name))
         (compiland *current-compiland*))
    (declare (type cblock block))
    (declare (type compiland compiland))
;;     (unless block
;;       (error "No block named ~S is currently visible." name))
    (aver (not (null (block-exit block))))
    (emit-clear-values) ; REVIEW
    (p2 result-form :eax)
    (cond ((eq (block-compiland block) compiland)
           (dolist (enclosing-block *visible-blocks*)
             (cond ((eq enclosing-block block)
                    (return))
                   ((block-tagbody-var enclosing-block)
                    (aver (compiland-thread-var compiland))
                    (inst :push :eax) ; save result
                    (inst :mov (block-tagbody-var enclosing-block) :eax) ; tagbody
                    (inst :push :eax)
                    (inst :mov (compiland-thread-var compiland) :eax) ; thread
                    (inst :push :eax)
                    (emit-call-2 "RT_leave_tagbody" :eax)
                    (inst :pop :eax)) ; restore result
                   ((equal (block-name enclosing-block) '(UNWIND-PROTECT))
                    (aver (block-cleanup-label enclosing-block))
                    (inst :push :eax)
                    (emit-call (block-cleanup-label enclosing-block))
                    (inst :pop :eax))
                   ((equal (block-name enclosing-block) '(CATCH))
                    (mumble "p2-return-from catch case~%")
                    (inst :push :eax) ; save result
                    (inst :mov (block-block-var enclosing-block) :eax) ; catch-frame
                    (inst :push :eax)
                    (inst :mov (compiland-thread-var compiland) :eax) ; thread
                    (inst :push :eax)
                    (emit-call-2 "RT_leave_catch" :eax)
                    (inst :pop :eax)))) ; restore result
           (emit-jmp-short t (block-exit block)))
          (t
           ;; non-local return
           (let ((thread-var (compiland-thread-var compiland)))
             (aver thread-var)
             (inst :push :eax) ; result
             (p2-symbol name :stack) ; name
             (inst :push thread-var)
             (emit-call-3 "RT_return_from" nil) ; doesn't return
             (inst :exit))))))

(defun p2-catch (form target)
  (let* ((block (cadr form))
         (block-var (block-block-var block))
         (thread-var (compiland-thread-var *current-compiland*)))
    (declare (type cblock block))
    (aver block-var)
    (aver thread-var)
    (p2 (cadr (block-form block)) :stack)
    (inst :push thread-var)
    (emit-call-2 "RT_enter_catch" :eax)
    (inst :mov :eax block-var) ; catch-frame
    (inst :push :eax)
    (emit-call-1 "RT_frame_jmp" :stack)
    (emit-call-1 "setjmp" :eax)
    (inst :test :eax :eax)
    (let ((LABEL1 (make-label))
          (EXIT (make-label)))
      (emit-jmp-short :nz LABEL1)
      (let ((*visible-blocks* (cons block *visible-blocks*)))
        (p2-progn-body (block-body block) :eax))
      (inst :push :eax) ; save result
      (inst :push block-var)
      (inst :push thread-var)
      (emit-call-2 "RT_leave_catch" nil)
      (inst :pop :eax) ; restore result
      (emit-jmp-short t EXIT)
      (label LABEL1)
      ;; caught THROW
      (inst :push block-var)
      (inst :push thread-var)
      (emit-call-2 "RT_caught_throw" :eax)
      (label EXIT))
    (move-result-to-target target)))

(defun p2-throw (form target)
  (aver (length-eql form 3))
  (let* ((args (%cdr form))
         (tag-form (%car args))
         (result-form (%cadr args))
         (thread-var (compiland-thread-var *current-compiland*)))
    (aver thread-var)
    (inst :sub 12 :esp)
    (inst :mov thread-var :eax)
    (emit-bytes #x89 #x04 #x24) ; mov %eax,(%esp)
    (p2 tag-form :eax)
    (emit-bytes #x89 #x44 #x24 #x04) ; mov %eax,0x4(%esp)
    (emit-clear-values) ; REVIEW
    (p2 result-form :eax)
    (emit-bytes #x89 #x44 #x24 #x08) ; mov %eax,0x8(%esp)
    (emit-call-3 "RT_throw" nil) ; doesn't return
    (move-result-to-target target)))

(defun p2-test-numeric-comparison (test-form label) ; jump to label if test fails
  (unless (eql (length test-form) 3)
    (return-from p2-test-numeric-comparison nil))
  (let* ((op (%car test-form))
         (args (%cdr test-form))
         (arg1 (%car args))
         (arg2 (%cadr args))
         (type1 (derive-type arg1))
         (type2 (derive-type arg2)))
    (cond ((and (fixnum-type-p type1)
                (fixnum-type-p type2))
           (cond ((and (fixnump arg1)
                       (fixnump arg2))
                  (if (funcall op arg1 arg2) :consequent :alternate))
                 ((eq op 'two-arg-=)
                  ;; = fixnums are EQ
                  (return-from p2-test-numeric-comparison (p2-test-eq test-form label)))
                 ((eq op 'two-arg-/=)
                  ;; /= fixnums are NEQ
                  (return-from p2-test-numeric-comparison (p2-test-neq test-form label)))
                 (t
                  (process-2-args args '(:eax :edx) t)
;;                   (emit-bytes #x39 #xd0) ; cmp %edx,%eax
                  (inst :cmp :edx :eax)
                  (emit-jmp-short (ecase op
                                    (two-arg-<  :nl)
                                    (two-arg->  :ng)
                                    (two-arg-<= :g)
                                    (two-arg->= :l)
                                    (two-arg-=  :ne)
                                    (two-arg-/= :e))
                                  label)
                  t)))
          ((or (float-type-p type1) (float-type-p type2))
           ;; full call
           (mumble "p2-test-numeric-comparison float case~%")
           (process-2-args args :stack t)
           (emit-call-2 op :eax)
           (inst :compare-immediate nil :eax)
           (emit-jmp-short :z label)
           t)
          (t
           (let ((FULL-CALL (gensym))
                 (EXIT (gensym)))
             (process-2-args args '(:eax :edx) t)
             ;; arg1 in eax, arg2 in edx
             (unless (fixnum-type-p type1)
               (inst :test +fixnum-tag-mask+ :al)
               (emit-jmp-short :nz FULL-CALL))
             (unless (fixnum-type-p type2)
               (inst :test +fixnum-tag-mask+ :dl)
               (emit-jmp-short :nz FULL-CALL))
             ;; falling through, both args are fixnums
             (inst :cmp :edx :eax)
             (emit-jmp-short (ecase op
                               (two-arg-<  :nl)
                               (two-arg->  :ng)
                               (two-arg-<= :g)
                               (two-arg->= :l)
                               (two-arg-=  :ne)
                               (two-arg-/= :e))
                             label)
             (emit-jmp-short t EXIT)
             (label FULL-CALL)
             (inst :push :edx)
             (inst :push :eax)
             (emit-call-2 op :eax)
             (inst :compare-immediate nil :eax)
             (emit-jmp-short :z label)
             (label EXIT)
             t)))))

(defknown p2-test-runtime-predicate (t t) t)
(defun p2-test-runtime-predicate (test-form label)
  (when (check-arg-count test-form 1) ; runtime predicates are unary
    (let* ((op (%car test-form))
           (runtime-name (gethash op *runtime-predicates*))
           (arg (%cadr test-form)))
      (when runtime-name
        (p2 arg :stack)
        (maybe-emit-clear-values arg)
        (emit-call-1 runtime-name :eax)
        (inst :test :al :al)
        (emit-jmp-short :z label)
        t))))

(defknown p2-runtime-predicate (t t) t)
(defun p2-runtime-predicate (form target)
  (when (check-arg-count form 1)
    (let* ((op (%car form))
           (runtime-name (gethash op *runtime-predicates*))
           (arg (%cadr form)))
      (when runtime-name
        (process-1-arg arg :stack t)
        (emit-call-1 runtime-name target)
        t))))

(defun p2-test-endp (test-form label-if-false)
  (when (check-arg-count test-form 1)
    (let ((arg (%cadr test-form)))
      (process-1-arg arg :eax t)
      (let* ((EXIT (make-label))
             (common-labels (compiland-common-labels *current-compiland*))
             (ERROR (gethash :error-not-list common-labels)))
        (unless ERROR
          (setq ERROR (make-label))
          (let ((*current-segment* :elsewhere))
            (label ERROR)
            (p2-symbol 'LIST :stack)
            ;; arg is in eax
            (inst :push :eax)
            (emit-call '%type-error)
            (inst :exit) ; FIXME
            (setf (gethash :error-not-list common-labels) ERROR)))
        (inst :compare-immediate nil :eax)
        (emit-jmp-short :e EXIT)
        (inst :push :eax)
        (inst :and +lowtag-mask+ :al)
        (inst :cmp +list-lowtag+ :al)
        (inst :pop :eax)
        (emit-jmp-short :ne ERROR)
        (emit-jmp-short t label-if-false)
        (label EXIT)
        t))))

(defknown %p2-test-eq (t t t) t)
(defun %p2-test-eq (test-form label-if-true label-if-false)
  (when (check-arg-count test-form 2)
    (let* ((args (%cdr test-form)))
      (process-2-args args '(:eax :edx) t)
      (inst :cmp :eax :edx)
      (when label-if-true
        (emit-jmp-short :e label-if-true))
      (when label-if-false
        (emit-jmp-short :ne label-if-false)))
    t))

(defknown p2-test-eq (t t) t)
(defun p2-test-eq (test-form label)
  (%p2-test-eq test-form nil label))

(defknown %p2-test-neq (t t t) t)
(defun %p2-test-neq (test-form label-if-true label-if-false)
  (when (check-arg-count test-form 2)
    (let* ((args (%cdr test-form)))
      (process-2-args args '(:eax :edx) t)
      (inst :cmp :eax :edx)
      (when label-if-true
        (emit-jmp-short :ne label-if-true))
      (when label-if-false
        (emit-jmp-short :e label-if-false)))
    t))

(defknown p2-test-neq (t t) t)
(defun p2-test-neq (test-form label)
  (%p2-test-neq test-form nil label))

(defknown %p2-test-eql (t t) t)
(defun %p2-test-eql (test-form label-if-true label-if-false)
  (when (check-arg-count test-form 2)
    (let* ((args (%cdr test-form))
           (arg1 (%car args))
           (arg2 (%cadr args))
           (type1 (derive-type arg1))
           type2)
      (cond ((or (fixnum-type-p type1)
                 (eq type1 'CHARACTER)
                 (eq type1 'SYMBOL)
                 (fixnum-type-p (setq type2 (derive-type arg2)))
                 (eq type2 'CHARACTER)
                 (eq type2 'SYMBOL))
             (%p2-test-eq test-form label-if-true label-if-false))
            (t
             (process-2-args args :stack t)
             (emit-call-2 "RT_eql" :eax)
             (inst :test :al :al)
             (when label-if-true
               (emit-jmp-short :nz label-if-true))
             (when label-if-false
               (emit-jmp-short :z label-if-false)))))
    t))

(defknown p2-test-eql (t t) t)
(defun p2-test-eql (test-form label)
  (%p2-test-eql test-form nil label))

(defknown %p2-test-two-arg-= (t t) t)
(defun %p2-test-two-arg-= (test-form label-if-true label-if-false)
  (when (check-arg-count test-form 2)
    (let* ((args (%cdr test-form))
           (arg1 (%car args))
           (arg2 (%cadr args))
           (type1 (derive-type arg1))
           (type2 (derive-type arg2)))
      (cond ((and (fixnum-type-p type1)
                  (fixnum-type-p type2))
             (process-2-args args '(:eax :edx) t)
             (inst :cmp :edx :eax)
             (when label-if-true
               (emit-jmp-short :e label-if-true))
             (when label-if-false
               (emit-jmp-short :ne label-if-false)))
            (t
             (process-2-args args :stack t)
             (emit-call-2 "RT_equals" :eax)
             (inst :test :al :al)
             (when label-if-true
               (emit-jmp-short :nz label-if-true))
             (when label-if-false
               (emit-jmp-short :z label-if-false)))))
    t))

(defknown p2-test-two-arg-= (t t) t)
(defun p2-test-two-arg-= (test-form label)
  (%p2-test-two-arg-= test-form nil label))

(defun p2-test-characterp (test-form label)
  (when (check-arg-count test-form 1)
    (let ((arg (cadr test-form)))
      (process-1-arg arg :eax t)
      (inst :and +lowtag-mask+ :al)
      (clear-register-contents :eax)
      (inst :cmp +character-lowtag+ :al)
      (emit-jmp-short :ne label))
    t))

(defknown %p2-test-listp (t t t) t)
(defun %p2-test-listp (form label-if-true label-if-false)
  (when (check-arg-count form 1)
    (let* ((arg (%cadr form))
           (EXIT (make-label)))
      (process-1-arg arg :eax t)
      (inst :and +lowtag-mask+ :al)
      (clear-register-contents :eax)
      (inst :cmp +list-lowtag+ :al)
      (when label-if-true
        (emit-jmp-short :e label-if-true))
      (when label-if-false
        (emit-jmp-short :ne label-if-false))
      (label EXIT))
    t))

(defknown p2-test-listp (t t) t)
(defun p2-test-listp (test-form label)
  (%p2-test-listp test-form nil label))

(defun p2-test-symbolp (test-form label)
  (when (check-arg-count test-form 1)
    (let ((arg (cadr test-form))
          (EXIT (make-label)))
      (process-1-arg arg :eax t)
      (inst :compare-immediate nil :eax)
      (emit-jmp-short :e EXIT)
      (inst :and +lowtag-mask+ :al)
      (clear-register-contents :eax)
      (inst :cmp +symbol-lowtag+ :al)
      (emit-jmp-short :ne label)
      (label EXIT))
    t))

(defun p2-test-atom (test-form label)
  (when (check-arg-count test-form 1)
    (let ((arg (%cadr test-form))
          (EXIT (make-label)))
      (process-1-arg arg :eax t)
      (inst :compare-immediate nil :eax)
      (emit-jmp-short :e EXIT)
      (inst :and +lowtag-mask+ :al)
      (clear-register-contents :eax)
      (inst :cmp +list-lowtag+ :al)
      (emit-jmp-short :e label)
      (label EXIT))
    t))

(defknown %p2-test-consp (t t t) t)
(defun %p2-test-consp (form label-if-true label-if-false)
  (when (check-arg-count form 1)
    (let* ((arg (%cadr form))
           (EXIT (make-label)))
      (process-1-arg arg :eax t)
      (inst :compare-immediate nil :eax)
      (if label-if-false
          (emit-jmp-short :e label-if-false)
          (emit-jmp-short :e EXIT))
      (inst :and +lowtag-mask+ :al)
      (clear-register-contents :eax)
      (inst :cmp +list-lowtag+ :al)
      (when label-if-true
        (emit-jmp-short :e label-if-true))
      (when label-if-false
        (emit-jmp-short :ne label-if-false))
      (label EXIT))
    t))

(defknown p2-test-consp (t t) t)
(defun p2-test-consp (test-form label)
  (%p2-test-consp test-form nil label))

(defun p2-test-fixnump (test-form label)
  (unless (check-arg-count test-form 1)
    (return-from p2-test-fixnump nil))
  (let ((arg (cadr test-form)))
    (process-1-arg arg :eax t)
    (inst :test +fixnum-tag-mask+ :al)
    (emit-jmp-short :nz label))
  t)

(defun %p2-test-plusp (form label-if-true label-if-false)
  (when (check-arg-count form 1)
    (let* ((arg (cadr form))
           (type (derive-type arg)))
      (cond ((equal type '(INTEGER 0 1))
             (mumble "%p2-test-plusp bit case~%")
             (process-1-arg arg :eax t)
             (inst :test :al :al)
             (when label-if-true
               (emit-jmp-short :nz label-if-true))
             (when label-if-false
               (emit-jmp-short :z label-if-false)))
            (t
             (mumble "%p2-test-plusp default case~%")
             (process-1-arg arg :stack t)
             (emit-call-1 "RT_plusp" :eax)
             (inst :test :al :al)
             (when label-if-true
               (emit-jmp-short :nz label-if-true))
             (when label-if-false
               (emit-jmp-short :z label-if-false)))))
    t))

(defknown p2-test-plusp (t t) t)
(defun p2-test-plusp (test-form label)
  (%p2-test-plusp test-form nil label))

(defun p2-test-zerop (test-form label)
  (unless (check-arg-count test-form 1)
    (return-from p2-test-zerop nil))
  (let* ((arg (cadr test-form))
         (type (derive-type arg))
         (EXIT (gensym)))
    (process-1-arg arg :eax t)
    (inst :test :eax :eax)
    (cond ((and (neq type :unknown)
                (subtypep type 'INTEGER))
           (emit-jmp-short :nz label))
          (t
           (emit-jmp-short :z EXIT)
           (inst :push :eax)
           (cond ((eql *speed* 3)
                  (emit-call 'zerop)
                  (emit-adjust-stack-after-call 1))
                 (t
                  (p2-symbol 'zerop :stack)
                  (emit-call (if (use-fast-call-p) "RT_fast_call_symbol_1" "RT_current_thread_call_symbol_1"))
                  (emit-adjust-stack-after-call 2)))
           (inst :compare-immediate nil :eax)
           (emit-jmp-short :z label)
           (label EXIT))))
  t)

(defun p2-test-form-default (test-form label) ; jump to label if test fails
  (process-1-arg test-form :eax t)
  (inst :compare-immediate nil :eax)
  (emit-jmp-short :z label))

(defknown p2-if-and (t t) t)
(defun p2-if-and (form target)
  (let* ((test (second form))
         (consequent (third form))
         (alternate (fourth form))
         (subforms (cdr test)))
    (aver (and (consp test) (eq (car test) 'AND)))
    (case (length subforms)
      (0
       (p2 consequent target))
      (1
       (p2-if (list 'IF (%car subforms) consequent alternate) target))
      (t
       (let ((LABEL1 (make-label))
             (LABEL2 (make-label)))
         (dolist (subform subforms)
           (let ((op (and (consp subform) (%car subform))))
             (cond ((eq op 'EQ)
                    (%p2-test-eq subform nil LABEL1))
                   ((eq op 'CONSP)
                    (%p2-test-consp subform nil LABEL1))
                   (t
                    (process-1-arg subform :eax t)
                    (inst :compare-immediate nil :eax)
                    (emit-jmp-short :e LABEL1)))))
         (p2 consequent target)
         (emit-jmp-short t LABEL2)
         (label LABEL1)
         (clear-register-contents)
         (clear-constraints)
         (p2 alternate target)
         (label LABEL2)
         (clear-register-contents)
         (clear-constraints))))))

(defknown p2-and (t t) t)
(defun p2-and (form target)
  ;; "AND passes back multiple values from the last subform but not from
  ;; subforms other than the last."
  (let ((subforms (cdr form)))
    (case (length subforms)
      (0
       (p2 t target))
      (1
       (p2 (%car subforms) target))
      (2
       ;; (and a b) => (if a b)
       (let ((new-form `(if ,(%car subforms) ,(%cadr subforms))))
         (p2 new-form target)))
      (t
       (let (;(*constraints* *constraints*)
             (FAIL (make-label))
             (DONE (make-label)))
         (loop
           (let ((subform (car subforms))
                 (tail (cdr subforms)))
             (cond ((null tail)
                    ;; last subform
                    (process-1-arg subform :eax nil)
                    (move-result-to-target target)
                    (unless (eq target :return)
                      (emit-jmp-short t DONE))
                    (return))
                   (t
                    ;; not the last subform
                    (process-1-arg subform :eax t)
                    (inst :compare-immediate nil :eax)
                    (emit-jmp-short :e FAIL)
                    (maybe-add-constraint subform)
                    (setq subforms tail)
                    ))))
         (label FAIL)
         (p2 nil target)
         (label DONE))
       (clear-register-contents)
       (clear-constraints)))))

(defknown p2-if-or (t t) t)
(defun p2-if-or (form target)
  (let* ((test (second form))
         (consequent (third form))
         (alternate (fourth form))
         (subforms (cdr test)))
    (case (length subforms)
      (0
       (p2 alternate target))
      (1
       (p2-if (list 'IF (%car subforms) consequent alternate) target))
      (t
       (let ((LABEL1 (make-label))
             (LABEL2 (make-label)))
         (dolist (subform subforms)
           (let ((op (and (consp subform) (%car subform))))
             (cond ((eq op 'EQ)
                    (%p2-test-eq subform LABEL1 nil))
                   ((eq op 'NEQ)
                    (%p2-test-neq subform LABEL1 nil))
                   ((eq op 'EQL)
                    (%p2-test-eql subform LABEL1 nil))
                   ((eq op 'TWO-ARG-=)
                    (%p2-test-two-arg-= subform LABEL1 nil))
                   ((gethash op *runtime-predicates*)
                    (p2-runtime-predicate subform :eax)
                    (inst :test :al :al)
                    (emit-jmp-short :nz LABEL1))
                   (t
                    ;;                       (if op
                    ;;                           (mumble "p2-if-or default op = ~S~%" op)
                    ;;                           (mumble "p2-if-or default~%"))
                    (p2 subform :eax)
                    (unless (single-valued-p subform)
                      (emit-clear-values :preserve :eax))
                    (inst :compare-immediate nil :eax)
                    (emit-jmp-short :ne LABEL1)))))
         (p2 alternate target)
         (emit-jmp-short t LABEL2)
         (label LABEL1)
         ;; many ways to get here, so register contents could be anything
         (clear-register-contents)
         (clear-constraints)
         (p2 consequent target)
         (label LABEL2)
         (clear-register-contents)
         (clear-constraints))))))

(defknown p2-or (t t) t)
(defun p2-or (form target)
  (let ((args (cdr form)))
    (case (length args)
      (0
       (p2 nil target))
      (1
       (p2 (%car args) target))
      (2
       (let ((arg1 (%car args))
             (arg2 (%cadr args))
             (EXIT (make-label)))
         (process-1-arg arg1 :eax t)
         (inst :compare-immediate nil :eax)
         (emit-jmp-short :ne EXIT)
         (process-1-arg arg2 :eax nil)
         (label EXIT)
         (clear-register-contents)
         (clear-constraints)
         (move-result-to-target target)))
      (t
       ;; (or a b c d e f) => (or a (or b c d e f))
       (let ((new-form `(or ,(%car args) (or ,@(%cdr args)))))
         (p2-or new-form target))))))

(defun emit-move-register-to-closure-var (reg var compiland)
  (aver (neq reg :ecx))
  (emit-move-local-to-register (compiland-closure-data-index compiland) :ecx)
  (clear-var-registers var)
  (inst :mov `(,(* (var-closure-index var) +bytes-per-word+) :ecx) :ecx)
  (inst :mov reg '(:ecx))
  (clear-register-contents :ecx)
  (set-register-contents reg var))

(defun emit-move-closure-var-to-register (var reg compiland)
  (emit-move-local-to-register (compiland-closure-data-index compiland) :ecx)
  (clear-register-contents :ecx)
  (inst :mov `(,(* (var-closure-index var) +bytes-per-word+) :ecx) :ecx)
  (inst :mov '(:ecx) reg)
  (set-register-contents reg var))

(defknown bind-var (var) t)
(defun bind-var (var)
  (declare (type var var))
  (let ((compiland *current-compiland*)
        (initform (var-initform var)))
    (declare (type compiland compiland))
    (cond ((var-constant-p var)
           ; nothing to do
           )
          ((var-special-p var)
           (when (var-ref-p initform)
             (let ((var-ref-var (var-ref-var initform)))
               (when (and (var-special-p var-ref-var)
                          (eq (var-name var-ref-var) (var-name var)))
                 (note "BIND-VAR: binding special to current value~%")
                 (p2-symbol (var-name var) :stack)
                 (let ((thread-var (compiland-thread-var compiland)))
                   (cond (thread-var
                          (inst :push thread-var)
                          (emit-call-2 "RT_thread_bind_special_to_current_value" nil))
                         (t
                          (note "BIND-VAR: emitting call to RT_current_thread_bind_special_to_current_value~%")
                          (emit-call-1 "RT_current_thread_bind_special_to_current_value" nil))))
                 (return-from bind-var))))
           (p2 initform :stack)
           (p2-constant (var-name var) :stack)
           (let ((thread-var (compiland-thread-var compiland)))
             (cond (thread-var
                    (inst :push thread-var)
                    (emit-call-3 "RT_thread_bind_special" nil))
                   (t
                    (note "BIND-VAR: emitting call to RT_current_thread_bind_special~%")
                    (emit-call-2 "RT_current_thread_bind_special" nil)))))
          ((zerop (var-reads var))
           (p2 initform nil))
          ((var-closure-index var)
           ;; each new binding gets a new value cell
           (p2 initform :stack)
           (emit-call-1 "RT_make_value_cell_1" :eax)
           (emit-move-local-to-register (compiland-closure-data-index compiland) :edx)
           (inst :mov :eax `(,(* (var-closure-index var) +bytes-per-word+) :edx)))
          (t
           (let ((derived-type (derive-type initform))
                 reg)
             (cond ((and (var-ref-p initform)
                         (setq reg (find-register-containing-var (var-ref-var initform))))
                    (inst :mov reg var)
                    (set-register-contents reg (list var (var-ref-var initform))))
                   ((var-register var)
                    (p2 initform (var-register var))
                    (when (integerp initform)
                      (add-type-constraint var `(INTEGER ,initform ,initform))))
                   (t
                    (p2 initform :eax)
                    (inst :mov :eax var)
                    (set-register-contents :eax var)
                    (when (integerp initform)
                      (add-type-constraint var `(INTEGER ,initform ,initform)))))
             (when (zerop (var-writes var))
               (setf (var-derived-type var) derived-type))))))
  (p2-check-var-type var t))

(defun p2-let-vars (vars)
  (let ((specials nil)
        (must-clear-values nil))
    (dolist (var vars)
      (declare (type var var))
      (cond ((var-special-p var)
             (push var specials)
             (p2 (var-initform var) :stack))
            (t
             (bind-var var)))
      (unless must-clear-values
        (unless (single-valued-p (var-initform var))
          (setq must-clear-values t))))
    (dolist (var specials)
      (declare (type var var))
      (when (var-special-p var)
        (p2-constant (var-name var) :stack)
        (let ((thread-var (compiland-thread-var *current-compiland*)))
          (cond (thread-var
                 (inst :push thread-var)
                 (emit-call-3 "RT_thread_bind_special" nil))
                (t
                 (note "P2-LET-VARS: emitting call to RT_current_thread_bind_special~%")
                 (emit-call-2 "RT_current_thread_bind_special" nil))))))
    (dolist (var vars)
      (push var *visible-variables*))
    (when must-clear-values
      (emit-clear-values))))

(defun p2-let*-vars (vars)
  (let ((must-clear-values nil))
    (dolist (var vars)
      (bind-var var)
      (push var *visible-variables*)
      (unless must-clear-values
        (unless (single-valued-p (var-initform var))
          (setq must-clear-values t))))
    (when must-clear-values
      (emit-clear-values))))

(defun p2-let/let* (form target)
  (aver (eql (length form) 2))
  (aver (memq (%car form) '(LET LET*)))
  (let* ((*visible-variables* *visible-variables*)
         (block (cadr form))
         (*visible-blocks* (cons block *visible-blocks*))
         (vars (block-vars block))
         (body (block-body block))
         (compiland *current-compiland*))
    (declare (type cblock block))
    (declare (type compiland compiland))
    (when (block-last-special-binding-var block)
      (let ((thread-var (compiland-thread-var compiland)))
        (cond (thread-var
;;                (inst :mov thread-var :eax)
;;                (emit-bytes #x8b #x40)
;;                (emit-byte +last-special-binding-offset+) ; mov 0x10(%eax),%eax
               (inst :push thread-var)
               (emit-call-1 "RT_thread_last_special_binding" :eax)
;;                (clear-register-contents :eax)
               )
              (t
               (mumble "P2-LET/LET*: emitting call to RT_current_thread_last_special_binding~%")
               (emit-call "RT_current_thread_last_special_binding"))))
      (inst :mov :eax (block-last-special-binding-var block)))
    (if (eq (%car form) 'LET)
        (p2-let-vars vars)
        (p2-let*-vars vars))
    ;; make free specials visible
    (dolist (var (block-free-specials block))
      (push var *visible-variables*))
    (let ((*speed*  *speed*)
          (*space*  *space*)
          (*safety* *safety*)
          (*debug*  *debug*)
          (*inline-declarations* *inline-declarations*)
          ;;(*explain* *explain*)
          )
      (process-optimization-declarations (cddr (block-form block)))
      (cond ((block-last-special-binding-var block)
             (p2-progn-body body :stack)
             ;; restore last special binding
             (cond ((compiland-thread-var compiland)
;;                     (inst :mov (block-last-special-binding-var block) :edx)
;;                     (inst :mov (compiland-thread-var compiland) :eax)
;;                     (inst :mov :edx `(,+last-special-binding-offset+ :eax))
                    (p2-var-ref (make-var-ref (block-last-special-binding-var block)) :stack)
                    (inst :push (compiland-thread-var compiland))
                    (emit-call-2 "RT_thread_set_last_special_binding" nil)
;;                     (clear-register-contents :eax :edx)
                    )
                   (t
                    (p2-var-ref (make-var-ref (block-last-special-binding-var block)) :stack)
                    (mumble "P2-LET/LET*: emitting call to RT_current_thread_set_last_special_binding~%")
                    (emit-call-1 "RT_current_thread_set_last_special_binding" nil)))
             (inst :pop :eax)
             (move-result-to-target target))
            (t
             (p2-progn-body body target))))))

(defun p2-m-v-b (form target)
  (let* ((*visible-variables* *visible-variables*)
         (block (second form))
         (values-form (third (block-form block)))
         (vars (block-vars block))
         (body (block-body block))
         (numvars (length vars))
         (compiland *current-compiland*)
         (thread-var (compiland-thread-var compiland)))
    (declare (type cblock block))
    (declare (type compiland compiland))
    (aver thread-var)
    (when (block-last-special-binding-var block)
      (inst :push thread-var)
      (emit-call-1 "RT_thread_last_special_binding" :eax)
      (inst :mov :eax (block-last-special-binding-var block)))
    (p2 values-form :eax)
    ;; push args right to left!
    (inst :push numvars) ; numvars
    (inst :push :eax) ; result
    (inst :push thread-var)
    (emit-call-3 "RT_thread_get_values" :eax)
    ;; pointer to values array is now in eax
    (let ((base-reg :eax)
          (value-reg :edx)
          (index 0))
      (unless (eq base-reg :eax)
        ;; if base-reg is callee-saved, we need to save it
        (inst :push base-reg)
        (inst :mov :eax base-reg))
      ;; pointer to values array is now in base-reg
      (dolist (var vars)
        (declare (type var var))
        (inst :mov `(,index ,base-reg) value-reg)
        (clear-register-contents value-reg)
        (incf index +bytes-per-word+)
        (cond ((var-special-p var)
               (inst :push base-reg)
               (inst :push value-reg)
               (p2-constant (var-name var) :stack)
               (inst :push thread-var)
               (emit-call-3 "RT_thread_bind_special" nil)
               (inst :pop base-reg))
              ((var-closure-index var)
               (inst :push base-reg)
               ;; each new binding gets a new value cell
               (mumble "p2-m-v-b new code~%")
               (inst :push value-reg)
               (emit-call-1 "RT_make_value_cell_1" :eax)
               (emit-move-local-to-register (compiland-closure-data-index compiland) :edx)
               (inst :mov :eax `(,(* (var-closure-index var) +bytes-per-word+) :edx))
               (inst :pop base-reg))
              (t
               (inst :mov value-reg var)
               (set-register-contents value-reg var)))
        (push var *visible-variables*))
      (unless (eq base-reg :eax)
        ;; restore base-reg
        (inst :pop base-reg)))
    (dolist (var vars)
      (p2-check-var-type var nil))
    (emit-clear-values)
    (cond ((block-last-special-binding-var block)
           (p2-progn-body body :stack)
           (p2-var-ref (make-var-ref (block-last-special-binding-var block)) :stack)
           (inst :push thread-var)
           (emit-call-2 "RT_thread_set_last_special_binding" nil)
           (inst :pop :eax)
           (move-result-to-target target))
          (t
           (p2-progn-body body target)))))

(defun p2-m-v-c (form target)
  (aver (length-eql form 2))
  (aver (eq (%car form) 'MULTIPLE-VALUE-CALL))
  (let* ((node (%cadr form))
         (function-form (%cadr (m-v-c-node-form node)))
         (values-producing-forms (cddr (node-form node)))
         (thread-var (compiland-thread-var *current-compiland*))
         (function-var (m-v-c-node-function-var node))
         (address-var (m-v-c-node-values-address-var node))
         (length-var (m-v-c-node-values-length-var node))
         (size (* multiple-values-limit (length values-producing-forms) +bytes-per-word+)))
    (aver thread-var)
    (process-1-arg function-form :eax nil)
    (inst :mov :eax function-var)
    (inst :sub size :esp)
    (inst :mov :esp address-var)
    (inst :xor :eax :eax)
    (inst :mov :eax length-var)
    (clear-register-contents)
    (emit-clear-values)
    (dolist (values-producing-form values-producing-forms)
      (p2 values-producing-form :eax)
      (clear-register-contents)
      (inst :push length-var)
      (inst :push address-var)
      (inst :push :eax)
      (inst :push thread-var)
      (emit-call-4 "RT_accumulate_values" :eax)
      (inst :mov :eax length-var))
    ;; done evaluating values-producing forms
    ;; RT_thread_multiple_value_call(thread, callable, vector-address, vector-length)
    (inst :push length-var) ; length
    (inst :push address-var) ; address
    (inst :push function-var) ; function designator
    (inst :push thread-var) ; thread
    (emit-call-4 "RT_thread_multiple_value_call" :eax)
    (inst :add size :esp)
    (move-result-to-target target)))

(defun p2-progv (form target)
  (declare (type cons form))
  (aver (eq (car form) 'PROGV))
  (aver (length-eql form 2))
  (let* ((*visible-variables* *visible-variables*)
         (block (cadr form))
         (*visible-blocks* (cons block *visible-blocks*))
         (args (cdr (block-form block)))
         (body (cddr args))
         (thread-var (compiland-thread-var *current-compiland*)))
    (declare (type cblock block))
    (aver (not (null thread-var)))
    (aver (not (null (block-last-special-binding-var block))))
    (inst :push thread-var)
    (emit-call-1 "RT_thread_last_special_binding" :eax)
    (inst :mov :eax (block-last-special-binding-var block))
    (process-2-args args :stack t)
    (inst :push thread-var)
    (emit-call-3 "RT_progv_bind_vars" nil)
    (p2-progn-body body :stack)
    (inst :push (block-last-special-binding-var block))
    (inst :push thread-var)
    (emit-call-2 "RT_thread_set_last_special_binding" nil)
    (inst :pop :eax) ; result
    (move-result-to-target target)))

(defun p2-m-v-l (form target)
  (aver (eql (length form) 2))
  (aver (eq (%car form) 'MULTIPLE-VALUE-LIST))
  (emit-clear-values)
  (p2 (%cadr form) :stack)
  (emit-call "RT_multiple_value_list")
  (emit-adjust-stack-after-call 1)
  (move-result-to-target target))

(defknown maybe-generate-interrupt-check () t)
(defun maybe-generate-interrupt-check ()
  (unless (> *speed* *safety*)
    (let ((LABEL1 (gensym)))
;;       (emit 'getstatic +lisp-class+ "interrupted" "Z")
;;       (emit 'ifeq `,label1)
;;       (emit-invokestatic +lisp-class+ "handleInterrupt" nil nil)
;;       (emit 'label `,label1))))
      (emit-bytes #x83 #x3d)
      (emit-raw (gethash2-1 "interrupted" *runtime-names*))
      (emit-byte #x0)
      (emit-jmp-short :z LABEL1)
      (emit-call "RT_handle_interrupt")
      (label LABEL1))))

(defun p2-tagbody (form target)
  (aver (eq (car form) 'TAGBODY))
  (aver (block-p (cadr form)))
  (let* ((block (cadr form))
         (*visible-blocks* (cons block *visible-blocks*))
         (*visible-tags* *visible-tags*)
         (body (block-body block)))
    (declare (type cblock block))
    (cond ((block-non-local-go-p block)
           (let ((thread-var (compiland-thread-var *current-compiland*))
                 (tagbody-var (block-tagbody-var block)))
             (aver thread-var)
             (aver tagbody-var)
             (inst :push thread-var)
             (emit-call-1 "RT_add_tagbody" :eax)
             (inst :mov :eax tagbody-var)
             ;; process tags
             (let ((index 0))
               (dolist (tag (block-tags block))
                 (declare (type tag tag))
                 (push tag *visible-tags*)
                 (when (tag-non-local-go-p tag)
                   (setf (tag-index tag) index)
                   (inst :push index)
                   (inst :push tagbody-var)
                   (p2-constant (tag-name tag) :stack)
                   (inst :push thread-var)
                   (emit-call-4 "RT_add_tag" :eax)
                   (incf index))))
             (inst :push tagbody-var)
             (emit-call-1 "RT_frame_jmp" :stack)
             (emit-call-1 "setjmp" :eax)
             (inst :test :eax :eax)
             (let ((LABEL1 (make-label))
                   (LABEL2 (make-label)))
               (emit-jmp-short :nz LABEL1)
               (p2-tagbody-1 body)
               (emit-jmp-short t LABEL2)
               (label LABEL1)
               ;; non-local GO
               (emit-byte #x48) ; dec %eax
               ;; convert index to byte offset
               (emit-bytes #x6b #xc0 #x05) ; imul $0x5,%rax,%rax
               (emit-bytes #xe8 #x00 #x00 #x00 #x00) ; call next instruction
               (inst :pop :edx) ; eip in edx
               (emit-bytes #x01 #xd0) ; add %rdx,%rax
               (emit-bytes #x83 #xc0 #x08) ; add $0x8,%eax
               (emit-bytes #xff #xe0) ; jmp *%eax
               (dolist (tag (block-tags block))
                 (when (tag-non-local-go-p tag)
                   (emit-jmp :jump-table (tag-label tag)))) ; 5 bytes each
               (label LABEL2))
             (inst :push tagbody-var)
             (inst :push thread-var)
             (emit-call-2 "RT_leave_tagbody" :eax)

             (emit-bytes #x31 #xc0)  ; xor %eax,%eax
             (inst :mov :eax tagbody-var)

             ))
          (t
           ;; make tags visible
           (dolist (tag (block-tags block))
             (push tag *visible-tags*))
           (p2-tagbody-1 body)))
    ;; TAGBODY returns NIL
    (p2 nil target)))

(defun p2-go (form target)
  (declare (ignore target))
  (let* ((name (cadr form))
         (tag (find-visible-tag name))
         (tag-block (tag-block tag))
         (compiland *current-compiland*))
    (declare (type compiland compiland))
    (unless tag
      (error "p2-go: tag not found: ~S" name))
;;     (maybe-generate-interrupt-check)
    (cond ((eq (tag-compiland tag) compiland)
           (dolist (enclosing-block *visible-blocks*)
             (cond ((eq enclosing-block tag-block)
                    (return))
                   ((equal (block-name enclosing-block) '(UNWIND-PROTECT))
                    (aver (block-cleanup-label enclosing-block))
                    (emit-call (block-cleanup-label enclosing-block)))
                   ((equal (block-name enclosing-block) '(CATCH))
                    (aver (block-block-var enclosing-block))
                    (aver (compiland-thread-var compiland))
                    (inst :push (block-block-var enclosing-block))
                    (inst :push (compiland-thread-var compiland))
                    (emit-call-2 "RT_leave_catch" nil))
                   ((and (consp (block-name enclosing-block))
                         (eq (%car (block-name enclosing-block)) 'TAGBODY))
                    ;; nothing to do
                    )
                   ((block-last-special-binding-var enclosing-block)
                    (aver (compiland-thread-var compiland))
                    (p2-var-ref (make-var-ref (block-last-special-binding-var enclosing-block)) :stack)
                    (inst :push (compiland-thread-var compiland))
                    (emit-call-2 "RT_thread_set_last_special_binding" nil))))
           (emit-jmp-short t (tag-label tag)))
          (t
           (p2-constant name :stack)
           (aver (compiland-thread-var compiland))
           (inst :push (compiland-thread-var compiland))
           (emit-call-2 "RT_non_local_go" nil) ; doesn't return
           (inst :exit)))))

(defun p2-unwind-protect (form target)
  (aver (eql (length form) 2))
  (let* ((block (cadr form))
         (protected-form (cadr (block-form block)))
         (cleanup-forms (cddr (block-form block)))
         (thread-var (compiland-thread-var *current-compiland*))
         (uwp-var (block-uwp-var block))
         (uwp-values-var (block-uwp-values-var block))
         (CLEANUP (make-label))
         (START (make-label)))
    (declare (type cblock block))
    (setf (block-cleanup-label block) CLEANUP)
    (emit-bytes #xe8 #x00 #x00 #x00 #x00) ; call next instruction (leave return address on stack)
    (emit-jmp t START)

    (label CLEANUP :external)
    (clear-register-contents)
    (clear-constraints)
    ;; "If a non-local exit occurs during execution of cleanup-forms, no special
    ;; action is taken. The cleanup-forms of UNWIND-PROTECT are not protected by
    ;; that UNWIND-PROTECT."
    (inst :push uwp-var)
    (inst :push thread-var)
    (emit-call-2 "RT_leave_unwind_protect" nil)
    (p2-progn-body cleanup-forms nil)
    (inst :ret) ; end of cleanup subroutine

    (label START)
    (clear-register-contents)
    (clear-constraints)
    (inst :pop :eax) ; return address left by call above
    (inst :add 5 :eax) ; code
    (inst :push :ebp) ; ebp
    (inst :push :eax) ; code
    (inst :push thread-var)
    (emit-call-3 "RT_enter_unwind_protect" :eax) ; returns uwp
    (inst :mov :eax uwp-var)
    (emit-clear-values)
    (let ((*visible-blocks* (cons block *visible-blocks*)))
      (p2 protected-form :eax))
    (inst :push :eax) ; primary value
    (inst :push thread-var)
    (emit-call-2 "RT_thread_copy_values" :eax) ; values
    (inst :mov :eax uwp-values-var)
    (emit-call CLEANUP)
    (inst :push uwp-values-var)
    (inst :push thread-var)
    (emit-call-2 "RT_thread_set_values" target)))

(defknown p2-flet (t t) t)
(defun p2-flet (form target)
  (let ((*local-functions* *local-functions*)
        (*visible-variables* *visible-variables*)
        (local-functions (cadr form))
        (compiland *current-compiland*)
        var)
    (dolist (local-function local-functions)
      (declare (type local-function local-function))
      (setq var (local-function-var local-function))
      (p2-flet-process-compiland local-function)
      (cond ((local-function-ctf local-function)
             (mumble "p2-flet case 1~%")
             (aver var)
             (cond ((var-closure-index var)
                    (let* ((closure-data-index (compiland-closure-data-index compiland)))
                      (aver (fixnump closure-data-index))
                      (emit-move-local-to-register closure-data-index :eax)
                      (inst :push :eax)
                      (p2-constant (local-function-ctf local-function) :stack)
                      (emit-call-2 "RT_make_compiled_closure" :eax)
                      (emit-move-register-to-closure-var :eax var compiland)))
                   (t
                    (let* ((closure-data-index (compiland-closure-data-index compiland)))
                      (aver (fixnump closure-data-index))
                      (emit-move-local-to-register closure-data-index :eax)
                      (inst :push :eax)
                      (p2-constant (local-function-ctf local-function) :stack)
                      (emit-call-2 "RT_make_compiled_closure" :eax)
                      (inst :mov :eax var)
                      (set-register-contents :eax var)))))
            ((local-function-ctf-name local-function)
             (mumble "p2-flet case 2~%")
             (aver var)
             (cond ((var-closure-index var)
                    (let* ((closure-data-index (compiland-closure-data-index compiland)))
                      (aver (fixnump closure-data-index))
                      (emit-move-local-to-register closure-data-index :eax)
                      (inst :push :eax)
                      (emit-move-function-to-register (local-function-ctf-name local-function) :eax)
                      (inst :push :eax)
                      (emit-call-2 "RT_make_compiled_closure" :eax)
                      (emit-move-register-to-closure-var :eax var compiland))
                    )
                   (t
                    (let* ((closure-data-index (compiland-closure-data-index compiland)))
                      (aver (fixnump closure-data-index))
                      (emit-move-local-to-register closure-data-index :eax)
                      (inst :push :eax)
                      (emit-move-function-to-register (local-function-ctf-name local-function) :eax)
                      (inst :push :eax)
                      (emit-call-2 "RT_make_compiled_closure" :eax)
                      (inst :mov :eax var)
                      (set-register-contents :eax var)))))
            ((local-function-function local-function)
             (mumble "p2-flet case 3~%")
             (aver (local-function-var local-function))
             (cond ((var-closure-index var)
                    (p2-constant (local-function-function local-function) :eax)
                    (emit-move-register-to-closure-var :eax var compiland))
                   (t
                    ;; nothing to do
                    )))
            (t
             (mumble "p2-flet case 4~%")
             (aver (local-function-callable-name local-function))
             (aver (local-function-var local-function))
             (cond ((var-closure-index var)
                    (p2-constant (local-function-callable-name local-function) :stack)
                    (emit-call-1 'SYMBOL-FUNCTION :eax)
                    (emit-move-register-to-closure-var :eax var compiland))
                    (t
                     (mumble "p2-flet case 4b~%")
                     ;; nothing to do
                     )))))
    (dolist (local-function local-functions)
      (push local-function *local-functions*))
    (multiple-value-bind (body declarations)
        (parse-body (cddr form))
      (declare (ignore declarations)) ; FIXME
      (p2-progn-body body target))))

(defknown p2-labels (t t) t)
(defun p2-labels (form target)
  (let ((*local-functions* *local-functions*)
        (*visible-variables* *visible-variables*)
        (local-functions (cadr form)))
    (dolist (local-function local-functions)
      (declare (type local-function local-function))
      (push local-function *local-functions*))
    (dolist (local-function local-functions)
      (declare (type local-function local-function))
      (p2-labels-process-compiland local-function)
      (cond ((local-function-ctf local-function)
             (mumble "p2-labels local-function-ctf case~%")
             (aver (local-function-var local-function))
             (aver (var-closure-index (local-function-var local-function)))
             (let* ((compiland *current-compiland*)
                    (closure-data-index (compiland-closure-data-index compiland)))
               (aver (fixnump closure-data-index))
               (emit-move-local-to-register closure-data-index :eax)
               (inst :push :eax)
               (p2-constant (local-function-ctf local-function) :stack)
               (emit-call-2 "RT_make_compiled_closure" :eax)
               (emit-move-register-to-closure-var :eax (local-function-var local-function) compiland)
               ))
            ((local-function-ctf-name local-function)
             (aver (local-function-var local-function))
             (aver (var-closure-index (local-function-var local-function)))
             (let* ((compiland *current-compiland*)
                    (closure-data-index (compiland-closure-data-index compiland)))
               (aver (fixnump closure-data-index))
               (emit-move-local-to-register closure-data-index :eax)
               (inst :push :eax)
               (emit-move-function-to-register (local-function-ctf-name local-function) :eax)
               (inst :push :eax)
               (emit-call-2 "RT_make_compiled_closure" :eax)
               (emit-move-register-to-closure-var :eax (local-function-var local-function) compiland)
               ))
            ((local-function-function local-function)
             (let* ((compiland *current-compiland*))
               (p2-constant (local-function-function local-function) :eax)
               (emit-move-register-to-closure-var :eax (local-function-var local-function) compiland)
               ))
            (t
             (aver (local-function-callable-name local-function))
             (let* ((compiland *current-compiland*))
               (p2-constant (local-function-callable-name local-function) :stack)
               (emit-call-1 'SYMBOL-FUNCTION :eax)
               (emit-move-register-to-closure-var :eax (local-function-var local-function) compiland)
               )))
      )
    (multiple-value-bind (body declarations)
        (parse-body (cddr form))
      (declare (ignore declarations)) ; REVIEW
      (p2-progn-body body target))))

(defun p2-multiple-value-prog1 (form target)
  (let* ((block (cadr form))
         (subforms (cdr (block-form block)))
         (thread-var (compiland-thread-var *current-compiland*)))
    (when (null subforms)
      (compiler-error
       "Wrong number of arguments for ~A (expected at least 1, but received 0)."
       'MULTIPLE-VALUE-PROG1))
    (emit-clear-values)
    (p2 (car subforms) :stack) ; primary value
    (inst :push thread-var)
    (emit-call-2 "RT_thread_copy_values" :eax) ; values
    (inst :mov :eax (block-values-var block))
    (dolist (subform (cdr subforms))
      (p2 subform nil))
    (inst :mov (block-values-var block) :eax)
    (inst :push :eax)
    (inst :push thread-var)
    (emit-call-2 "RT_thread_set_values" target)))

(defknown p2-closure (t t) t)
(defun p2-closure (compiland target)
  (aver (compiland-child-p compiland))
  (let ((compile-file-p (compile-file-p))
        (minargs (compiland-minargs compiland))
        (maxargs (compiland-maxargs compiland))
        code
        ctf
        compiled-function)
    (let ((*current-compiland* compiland)
          (*code* nil))
      (p2-compiland compiland)
      (setq code *code*))
    (cond (*closure-vars*
             (cond (compile-file-p
                    (dump-top-level-form
                     `(multiple-value-bind (final-code final-constants)
                          (generate-code-vector ',code ',(compiland-constants compiland))
                        (set-fdefinition ',(compiland-name compiland)
                                         (make-closure-template-function
                                          ',(compiland-name compiland)
                                          final-code
                                          ,minargs
                                          ,maxargs
                                          final-constants)))
                     *compile-file-output-stream*))
                   (t
                    (multiple-value-bind (final-code final-constants)
                        (generate-code-vector code (compiland-constants compiland))
                      (setq ctf (make-closure-template-function
                                 (compiland-name compiland)
                                 final-code
                                 minargs
                                 maxargs
                                 final-constants))
                      (aver (compiland-child-p compiland))
                      (push ctf (compiland-constants (compiland-parent compiland))))))
           (inst :push (length *closure-vars*))
           (emit-move-local-to-register (compiland-closure-data-index *current-compiland*) :eax)
           (inst :push :eax)
           (emit-call-2 "RT_copy_closure_data_vector" :eax) ; copy of closure data vector in eax
           (inst :push :eax) ; copy of closure data vector
           (cond (compile-file-p
                  (emit-move-function-to-register (compiland-name compiland) :eax)
                  (inst :push :eax))
                 (t
                  (aver ctf)
                  (emit-push-immediate ctf)))
           (emit-call-2 "RT_make_compiled_closure" :eax))
          (t
           ;; no closure vars
           (cond (compile-file-p
                  (dump-top-level-form
                   `(multiple-value-bind (final-code final-constants)
                        (generate-code-vector ',code ',(compiland-constants compiland))
                      (set-fdefinition ',(compiland-name compiland)
                                       (make-compiled-function
                                        ',(compiland-name compiland)
                                        final-code
                                        ,minargs
                                        ,maxargs
                                        final-constants)))
                   *compile-file-output-stream*)
                  (emit-byte #xb8) ; mov imm32,%eax
                  (emit-function (compiland-name compiland)))
                 (t
                  (multiple-value-bind (final-code final-constants)
                      (generate-code-vector code (compiland-constants compiland))
                    (setq compiled-function
                          (make-compiled-function
                           (compiland-name compiland)
                           final-code
                           minargs
                           maxargs
                           final-constants)))
                  (save-local-variable-information compiled-function)
                  (emit-move-immediate compiled-function :eax)
                  ;; REVIEW escaping closures will never be gc'ed
                  (push compiled-function (compiland-constants *current-compiland*)))))))
  (move-result-to-target target))

(defun p2-function (form target)
  (let ((arg (cadr form))
        local-function)
    (cond ((symbolp arg) ; #'foo
           (cond ((setq local-function (find-local-function arg))
;;                   (compiler-unsupported "P2-FUNCTION: local functions are not supported yet")
                  (mumble "p2-function local function case~%")
                  (cond #+nil
                        ((local-function-function local-function)
                         (p2-constant local-function-function local-function))
                        ((local-function-callable-name local-function)
                         (emit-move-function-to-register (local-function-callable-name local-function) :eax)
                         (clear-register-contents :eax)
                         (move-result-to-target target))
                        ((local-function-function local-function)
                         (emit-move-immediate (local-function-function local-function) :eax)
                         (clear-register-contents :eax)
                         (move-result-to-target target))
                        ((local-function-var local-function)
                         (p2-var-ref (make-var-ref (local-function-var local-function)) target))
                        (t
                         (compiler-unsupported "p2-function local function case unsupported situation")))
                  )
                 ((kernel-function-p arg)
                  (case target
                    (:stack
                     (emit-byte #xb8) ; mov imm32,%eax
                     (emit-function arg)
                     (inst :push :eax)
                     (clear-register-contents))
                    ((:eax :ecx :edx :ebx :esp :ebp :esi :edi)
                     (emit-byte (+ #xb8 (register-number target))) ; mov imm32,reg
                     (emit-function arg)
                     (clear-register-contents))
                    (:return
                     (emit-byte #xb8) ; mov imm32,%eax
                     (emit-function arg)
                     (inst :exit)
                     (clear-register-contents))
                    (t
                     (compiler-unsupported "P2-FUNCTION: unsupported target ~S" target))))
                 (t
                  (p2-constant arg :stack)
                  (emit-call "RT_symbol_function")
                  (emit-adjust-stack-after-call 1)
                  (move-result-to-target target))))
          ((setf-function-name-p arg)
           (cond((setq local-function (find-local-function arg))
;;                  (compiler-unsupported "P2-FUNCTION: local setf functions are not supported yet")
                 (cond #+nil
                       ((local-function-function local-function)
                        (p2-constant local-function-function local-function))
                       ((local-function-callable-name local-function)
                        (emit-move-function-to-register (local-function-callable-name local-function) :eax)
                        (clear-register-contents :eax)
                        (move-result-to-target target))
                       ((local-function-function local-function)
                        (emit-move-immediate (local-function-function local-function) :eax)
                        (clear-register-contents :eax)
                        (move-result-to-target target))
                       ((local-function-var local-function)
                        (p2-var-ref (make-var-ref (local-function-var local-function)) target))
                       (t
                        (compiler-unsupported "p2-function local function case unsupported situation")))
                 )
                (t
                 (p2-constant (cadr arg) :stack)
                 (emit-call "RT_symbol_setf_function")
                 (emit-adjust-stack-after-call 1)
                 (move-result-to-target target))))
          ((compiland-p arg)
           (p2-closure arg target))
          (t
           (compiler-unsupported "P2-FUNCTION unsupported situation")))))

(defknown p2-schar (t t) t)
(defun p2-schar (form target)
  (when (length-eql form 3)
    (let* ((args (%cdr form))
           (arg1 (%car args))
           (arg2 (%cadr args))
           type1)
      (cond ((zerop *safety*)
             (clear-register-contents)
             (process-2-args args '(:eax :edx) t) ; string in eax, offset in edx
             (inst :add (- +simple-string-data-offset+ +typed-object-lowtag+) :eax)
             (emit-bytes #xc1 #xfa +fixnum-shift+) ; sar $0x2,%edx
             (inst :add :eax :edx)
             (emit-bytes #x0f #xb6 #x02) ; movzbl (%edx),%eax
             (inst :shl +character-shift+ :eax)
             (emit-bytes #x83 #xc8 +character-lowtag+) ; or $0x6,%eax
             (move-result-to-target target))
            ((and (neq (setq type1 (derive-type arg1)) :unknown)
                  (subtypep (derive-type arg1) 'SIMPLE-STRING))
             (mumble "p2-schar derived type is subtypep simple-string~%")
             (p2-function-call (list '%SCHAR arg1 arg2) target))
            (t
             (mumble "p2-schar no optimization~%")
             (p2-function-call form target)
             (when (var-ref-p arg1)
               (let ((var (var-ref-var arg1)))
                 (unless (or (var-special-p var)
                             (var-used-non-locally-p var))
                   (add-type-constraint var 'SIMPLE-STRING)))))))
    t))

(defknown p2-schar (t t) t)
(defun p2-set-schar (form target)
  (when (length-eql form 4)
    (let* ((args (%cdr form)))
      (cond ((zerop *safety*)
             (mumble "p2-set-schar zero safety case~%")
             (process-3-args args '(:eax :edx :ecx) t) ; string in eax, index in edx, char in ecx
             (inst :add (- +simple-string-data-offset+ +typed-object-lowtag+) :eax)
             (unbox-fixnum :edx)
             (clear-register-contents :eax :edx)
             (inst :add :edx :eax)
             (when target
               (inst :push :ecx)) ; save char for return value
             (unbox-character :ecx)
             ;; store it in the array
             (inst :mov :cl '(:eax))
             (when target
               (inst :pop :eax)) ; return value
             (move-result-to-target target))
            (t
             (mumble "p2-set-schar default case~%")
             (p2-function-call form target))))
    t))

(defknown p2-svref (t t) t)
(defun p2-svref (form target)
  (when (check-arg-count form 2)
    (let* ((args (%cdr form))
           (arg1 (%car args))
           (arg2 (%cadr args))
           (type1 (derive-type arg1))
           (type2 (derive-type arg2))
           size)
      (cond ((or (zerop *safety*)
                 (and (integer-type-p type2)
                      (subtypep type1 'simple-vector)
                      (setq size (derive-vector-size type1))
                      (subtypep type2 (list 'INTEGER 0 (1- size)))))
             (cond ((fixnump arg2)
                    (process-1-arg arg1 :eax t)
                    (clear-register-contents :eax)
                    (let ((offset (+ (- +simple-vector-data-offset+ +typed-object-lowtag+)
                                           (* arg2 +bytes-per-word+))))
                      (cond ((reg32-p target)
                             (inst :mov `(,offset :eax) target))
                            (t
                             (inst :mov `(,offset :eax) :eax)
                             (move-result-to-target target)))))
                   (t
                    (process-2-args args '(:eax :edx) t) ; vector in eax, index in edx
                    (clear-register-contents :eax :edx)
                    (inst :add (- +simple-vector-data-offset+ +typed-object-lowtag+) :eax)
                    ;; index is in edx
                    ;; get rid of the fixnum shift and multiply by 4 to get the offset in bytes
                    ;; (emit-bytes #xc1 #xfa +fixnum-shift+)         ; sar $0x2,%edx
                    ;; (emit-bytes #xc1 #xe2 #x02)                   ; shl $0x2,%edx
                    ;; nothing to do!
                    (inst :add :edx :eax)
                    (cond ((reg32-p target)
                           (inst :mov '(:eax) target))
                          (t
                           (inst :mov '(:eax) :eax)
                           (move-result-to-target target))))))
            ((subtypep type1 'simple-vector)
             (mumble "p2-svref %svref case~%")
             (process-2-args args '(:eax :edx) t) ; vector in eax, tagged index in edx
             (unless (fixnum-type-p type2)
               (let* ((common-labels (compiland-common-labels *current-compiland*))
                      (SVREF-ERROR-NOT-FIXNUM (gethash :svref-error-not-fixnum common-labels)))
                 (unless SVREF-ERROR-NOT-FIXNUM
                   (setq SVREF-ERROR-NOT-FIXNUM (make-label))
                   (let ((*current-segment* :elsewhere)
                         (*register-contents* (copy-register-contents)))
                     (label SVREF-ERROR-NOT-FIXNUM)
                     (p2-symbol 'FIXNUM :stack)
                     (inst :push :edx)
                     (emit-call-2 '%type-error nil)
                     (inst :exit) ; FIXME
                     (setf (gethash :svref-error-not-fixnum common-labels) SVREF-ERROR-NOT-FIXNUM)))
                 (inst :test +fixnum-tag-mask+ :dl)
                 (emit-jmp-short :nz SVREF-ERROR-NOT-FIXNUM)))
             (let* ((displacement (- +vector-capacity-offset+ +typed-object-lowtag+))
                    (common-labels (compiland-common-labels *current-compiland*))
                    (SVREF-ERROR-BAD-INDEX (gethash :svref-error-bad-index common-labels)))
               (unless SVREF-ERROR-BAD-INDEX
                 (setq SVREF-ERROR-BAD-INDEX (make-label))
                 (let ((*current-segment* :elsewhere)
                       (*register-contents* (copy-register-contents)))
                   (label SVREF-ERROR-BAD-INDEX)
                   (inst :push :ecx)
                   (inst :push :edx)
                   (emit-call-2 "RT_bad_index" nil)
                   (inst :exit) ; FIXME
                   (setf (gethash :svref-error-bad-index common-labels) SVREF-ERROR-BAD-INDEX)))
               (inst :mov `(,displacement :eax) :ecx) ; raw length in ecx
               (clear-register-contents :ecx)
               (unbox-fixnum :edx)
               (inst :cmp :edx :ecx)
               (emit-jmp-short :le SVREF-ERROR-BAD-INDEX)
               (inst :shl 2 :edx) ; multiply by 4 to get offset in bytes
               (inst :add (- +simple-vector-data-offset+ +typed-object-lowtag+) :eax)
               (inst :add :edx :eax)
               (clear-register-contents :eax :edx)
               (inst :mov '(:eax) :eax)
               (move-result-to-target target)))
            (t
             (mumble "p2-svref full call~%")
             (p2-function-call form target)
             (when (var-ref-p arg1)
               (add-type-constraint (var-ref-var arg1) 'SIMPLE-VECTOR)))))
    t))

(defknown p2-vector-ref (t t) t)
(defun p2-vector-ref (form target)
  (when (check-arg-count form 2)
    (let* ((args (%cdr form))
           (arg1 (%car args))
           (arg2 (%cadr args))
           (type1 (derive-type arg1))
           type2
           size)
      (cond ((eq type1 :unknown)
             nil)
            ((subtypep type1 'simple-vector)
             (p2-svref form target))
            ((subtypep type1 '(simple-array (unsigned-byte 8) (*)))
             (cond ((or (zerop *safety*)
                        (and (neq (setq type2 (derive-type arg2)) :unknown)
                             (integer-type-p type2)
                             (setq size (derive-vector-size type1))
                             (subtypep type2 `(INTEGER 0 ,(1- size)))))
                    (mumble "p2-vector-ref new case~%")
                    (process-2-args args '(:eax :edx) t) ; vector in rax, index in rdx
                    (clear-register-contents :eax :edx)
                    (inst :add (- +simple-vector-data-offset+ +typed-object-lowtag+) :eax)

                    ;; index is in edx
                    ;; get rid of the fixnum shift
                    (unbox-fixnum :edx)

                    (inst :add :edx :eax)
                    (emit-bytes #x0f #xb6 #x00) ; movzbl (%eax),%eax
                    (box-fixnum :eax)
                    (move-result-to-target target)
                    t)
                   (t
                    (p2 `(%VECTOR-REF ,@args) target)
                    t)))
            ((subtypep type1 'vector)
             (p2 (list* '%VECTOR-REF args) target)
             t)
            (t
             nil)))))

(defknown p2-vector-set (t t) t)
(defun p2-vector-set (form target)
  (when (check-arg-count form 3)
    (let* ((args (%cdr form))
           (arg1 (%car args))
           (type1 (derive-type arg1)))
      (cond ((eq type1 :unknown)
             nil)
            ((subtypep type1 'simple-vector)
             (p2-svset form target))
            ((subtypep type1 'vector)
             (p2 (list* '%VECTOR-SET args) target)
             t)
            (t
             nil)))))

(defknown p2-svset (t t) t)
(defun p2-svset (form target)
  (when (check-arg-count form 3)
    (let* ((args (%cdr form))
           (arg1 (%car args))
           (arg2 (%cadr args))
           (arg3 (%caddr args))
           (type1 (derive-type arg1))
           (type2 (derive-type arg2))
           size)
      (cond ((or (zerop *safety*)
                 (and (integer-type-p type2)
                      (subtypep type1 'SIMPLE-VECTOR)
                      (setq size (derive-vector-size type1))
                      (subtypep type2 (list 'INTEGER 0 (1- size)))))
             (process-3-args args '(:eax :edx :ecx) t) ; vector in eax, index in edx, new element in ecx
             (clear-register-contents :eax :edx)
             (inst :add (- +simple-vector-data-offset+ +typed-object-lowtag+) :eax)
             ;; boxed index is in edx
             ;; unbox it
             ;; (inst :sar +fixnum-shift+ :edx)
             ;; multiply by +bytes-per-word+ to get the offset in bytes
             ;; (inst :shl 2 :edx)
             ;; nothing to do as long as +bytes-per-word+ is 4 and +fixnum-shift+ is 2
             (aver (eql +bytes-per-word+ 4))
             (aver (eql +fixnum-shift+ 2))
             (inst :add :edx :eax)
             ;; new element is in ecx
             ;; store it in the array
             (inst :mov :ecx '(:eax))
             ;; return value
             (cond ((null target)
                    ; nothing to do
                    )
                   ((reg32-p target)
                    (unless (eq target :ecx)
                      (inst :mov :ecx target)
                      (clear-register-contents target)))
                   ((eq target :stack)
                    (inst :push :ecx))
                   ((eq target :return)
                    (inst :mov :ecx :eax))
                   (t
                    (compiler-unsupported "p2-svset target = ~S" target)))
             t)
            ((and (neq type1 :unknown)
                  (subtypep type1 'SIMPLE-VECTOR))
             (mumble "p2-svset known simple-vector case~%")
             (p2-function-call `(%svset ,arg1 ,arg2 ,arg3) target)
             t)
            (t
             nil)))))

(defknown p2-symbol (t t) t)
(defun p2-symbol (form target)
  (declare (type symbol form))
  (cond ((compile-file-p)
         (p2-constant form target))
        ((eq target :stack)
         (inst :push `(:constant ,form)))
        (t
         (emit-move-immediate form target))))

(defknown process-1-arg (t t t) t)
(defun process-1-arg (arg target clear-values-p)
  (when (eq target :default)
    (setq target :stack))
  (p2 arg target)
  (when clear-values-p
    (unless (single-valued-p arg)
      (emit-clear-values :preserve target))))

(defknown process-2-arg (t t t) t)
(defun process-2-args (args targets clear-values-p)
  (when (eq targets :default)
    (setq targets :stack))
  (let* ((arg1 (%car args))
         (arg2 (%cadr args)))
    (cond ((eq targets :stack)
           (cond ((and (constant-or-local-var-ref-p arg1)
                       (constant-or-local-var-ref-p arg2))
                  ;; REVIEW there are other safe possibilities!
                  ;; order of evaluation doesn't matter
                  ;; push args from right to left
                  (p2 arg2 :stack)
                  (p2 arg1 :stack))
                 ((or (numberp arg1) (characterp arg1))
                  (p2 arg2 :stack)
                  (when clear-values-p
                    (unless (single-valued-p arg2)
                      (emit-clear-values)))
                  (p2 arg1 :stack))
                 ((or (numberp arg2) (characterp arg2))
                  (p2 arg2 :stack)
                  (p2 arg1 :stack)
                  (when clear-values-p
                    (unless (single-valued-p arg1)
                      (emit-clear-values))))
                 (t
                  ;; order of evaluation may matter
                  (inst :sub (* +bytes-per-word+ 2) :esp)
                  (p2 arg1 :eax)
                  (emit-bytes #x89 #x04 #x24) ; mov %eax,(%esp)
                  (p2 arg2 :eax)
                  (inst :mov :eax `(,+bytes-per-word+ :esp))
                  (when clear-values-p
                    (maybe-emit-clear-values arg1 arg2)))))
          ((and (consp targets)
                (length-eql targets 2)
                (memq (%car targets) '(:eax :ecx :edx))
                (memq (%cadr targets) '(:eax :ecx :edx)))
           (let ((reg1 (%car targets))
                 (reg2 (%cadr targets)))
             (cond ((and (constant-or-local-var-ref-p arg1)
                         (constant-or-local-var-ref-p arg2))
                    (p2 arg1 reg1)
                    (if (eq arg1 arg2)
                        (inst :mov reg1 reg2)
                        (p2 arg2 reg2)))
                   ((or (numberp arg1) (characterp arg1))
                    (p2 arg2 reg2)
                    (when clear-values-p
                      (unless (single-valued-p arg2)
                        (emit-clear-values :preserve reg2)))
                    (p2 arg1 reg1))
                   ((or (numberp arg2) (characterp arg2))
                    (p2 arg1 reg1)
                    (when clear-values-p
                      (unless (single-valued-p arg1)
                        (emit-clear-values :preserve reg1)))
                    (p2 arg2 reg2))
                   ((and (single-valued-p arg1)
                         (single-valued-p arg2))
                    (p2 arg1 :stack)
                    (p2 arg2 reg2)
                    (inst :pop reg1)
                    (clear-register-contents reg1))
                   (t
                    (p2 arg1 :stack)
                    (p2 arg2 :stack)
                    (when clear-values-p
                      (maybe-emit-clear-values arg1 arg2))
                    (inst :pop reg2)
                    (inst :pop reg1)
                    (clear-register-contents reg1 reg2)))
             ))
          (t
           (compiler-unsupported "PROCESS-2-ARGS unsupported targets ~S" targets)))))

(defknown process-3-args (t t t) t)
(defun process-3-args (args targets clear-values-p)
  (when (eq targets :default)
    (setq targets :stack))
  (let* ((arg1 (%car args))
         (arg2 (%cadr args))
         (arg3 (%caddr args)))
    (cond ((eq targets :stack)
           (cond ((every #'constant-or-local-var-ref-p args)
                  (p2 arg3 :stack)
                  (p2 arg2 :stack)
                  (p2 arg1 :stack))
                 (t
                  (emit-bytes #x83 #xec #x0c) ; sub $0xc,%esp
                  (p2 arg1 :eax)
                  (emit-bytes #x89 #x04 #x24) ; mov %eax,(%esp)
                  (p2 arg2 :eax)
                  (emit-bytes #x89 #x44 #x24 #x04) ; mov %eax,0x4(%esp)
                  (p2 arg3 :eax)
                  (emit-bytes #x89 #x44 #x24 #x08) ; mov %eax,0x8(%esp)
                  (when clear-values-p
                    (maybe-emit-clear-values arg1 arg2 arg3)))))
          ((and (consp targets)
                (length-eql targets 3)
                (memq (%car targets) '(:eax :ecx :edx))
                (memq (%cadr targets) '(:eax :ecx :edx))
                (memq (%caddr targets) '(:eax :ecx :edx)))
           (let ((reg1 (%car targets))
                 (reg2 (%cadr targets))
                 (reg3 (%caddr targets)))
             (cond ((every #'constant-or-local-var-ref-p args)
                    (p2 arg1 reg1)
                    (p2 arg2 reg2)
                    (p2 arg3 reg3))
                   (t
                    (p2 arg1 :stack)
                    (p2 arg2 :stack)
                    (p2 arg3 :stack)
                    (when clear-values-p
                      (maybe-emit-clear-values arg1 arg2 arg3))
                    (inst :pop reg3)
                    (inst :pop reg2)
                    (inst :pop reg1)
                    (clear-register-contents reg1 reg2 reg3)))))
          (t
           (compiler-unsupported "PROCESS-3-ARGS unsupported targets ~S" targets)))))

(defknown process-4-args (t t t) t)
(defun process-4-args (args targets clear-values-p)
  (let* ((arg1 (%car args))
         (arg2 (%cadr args))
         (arg3 (%caddr args))
         (arg4 (fourth args)))
    (cond ((eq targets :stack)
           (cond ((every #'constant-or-local-var-ref-p args)
                  (p2 arg4 :stack)
                  (p2 arg3 :stack)
                  (p2 arg2 :stack)
                  (p2 arg1 :stack))
                 (t
                  (inst :sub (* +bytes-per-word+ 4) :esp)
                  (p2 arg1 :eax)
                  (inst :mov :eax '(:esp))
                  (p2 arg2 :eax)
                  (inst :mov :eax `(,+bytes-per-word+ :esp))
                  (p2 arg3 :eax)
                  (inst :mov :eax `(,(* +bytes-per-word+ 2) :esp))
                  (p2 arg4 :eax)
                  (inst :mov :eax `(,(* +bytes-per-word+ 3) :esp))
                  (when clear-values-p
                    (maybe-emit-clear-values arg1 arg2 arg3 arg4)))))
          (t
           (compiler-unsupported "PROCESS-4-ARGS unsupported targets ~S" targets)))))

(defknown process-5-args (t t t) t)
(defun process-5-args (args targets clear-values-p)
  (let* ((arg1 (%car args))
         (arg2 (%cadr args))
         (arg3 (%caddr args))
         (arg4 (fourth args))
         (arg5 (fifth args)))
    (cond ((eq targets :stack)
           (cond ((every #'constant-or-local-var-ref-p args)
                  (p2 arg5 :stack)
                  (p2 arg4 :stack)
                  (p2 arg3 :stack)
                  (p2 arg2 :stack)
                  (p2 arg1 :stack))
                 (t
                  (emit-bytes #x83 #xec #x14) ; sub $0x14,%esp
                  (p2 arg1 :eax)
                  (emit-bytes #x89 #x04 #x24) ; mov %eax,(%esp)
                  (p2 arg2 :eax)
                  (emit-bytes #x89 #x44 #x24 #x04) ; mov %eax,0x4(%esp)
                  (p2 arg3 :eax)
                  (emit-bytes #x89 #x44 #x24 #x08) ; mov %eax,0x8(%esp)
                  (p2 arg4 :eax)
                  (emit-bytes #x89 #x44 #x24 #x0c) ; mov %eax,0xc(%esp)
                  (p2 arg5 :eax)
                  (emit-bytes #x89 #x44 #x24 #x10) ; mov %eax,0x10(%esp)
                  (when clear-values-p
                    (maybe-emit-clear-values arg1 arg2 arg3 arg4 arg5)))))
          (t
           (compiler-unsupported "PROCESS-5-ARGS unsupported targets ~S" targets)))))

(defknown process-6-args (t t t) t)
(defun process-6-args (args targets clear-values-p)
  (let* ((arg1 (%car args))
         (arg2 (%cadr args))
         (arg3 (%caddr args))
         (arg4 (fourth args))
         (arg5 (fifth args))
         (arg6 (sixth args)))
    (cond ((eq targets :stack)
           (cond ((every #'constant-or-local-var-ref-p args)
                  (p2 arg6 :stack)
                  (p2 arg5 :stack)
                  (p2 arg4 :stack)
                  (p2 arg3 :stack)
                  (p2 arg2 :stack)
                  (p2 arg1 :stack))
                 (t
                  (emit-bytes #x83 #xec #x18) ; sub $0x18,%esp
                  (p2 arg1 :eax)
                  (emit-bytes #x89 #x04 #x24) ; mov %eax,(%esp)
                  (p2 arg2 :eax)
                  (emit-bytes #x89 #x44 #x24 #x04) ; mov %eax,0x4(%esp)
                  (p2 arg3 :eax)
                  (emit-bytes #x89 #x44 #x24 #x08) ; mov %eax,0x8(%esp)
                  (p2 arg4 :eax)
                  (emit-bytes #x89 #x44 #x24 #x0c) ; mov %eax,0xc(%esp)
                  (p2 arg5 :eax)
                  (emit-bytes #x89 #x44 #x24 #x10) ; mov %eax,0x10(%esp)
                  (p2 arg6 :eax)
                  (emit-bytes #x89 #x44 #x24 #x14) ; mov %eax,0x14(%esp)
                  (when clear-values-p
                    (maybe-emit-clear-values arg1 arg2 arg3 arg4 arg5 arg6)))))
          (t
           (compiler-unsupported "PROCESS-6-ARGS unsupported targets ~S" targets)))))

(defknown process-args (t t t) t)
(defun process-args (args targets clear-values-p)
  (ecase (length args)
    (0) ; nothing to do
    (1 (process-1-arg (%car args) targets clear-values-p))
    (2 (process-2-args args targets clear-values-p))
    (3 (process-3-args args targets clear-values-p))
    (4 (process-4-args args targets clear-values-p))
    (5 (process-5-args args targets clear-values-p))
    (6 (process-6-args args targets clear-values-p))))

(defknown p2-function-call-0 (t t) t)
(defun p2-function-call-0 (op target)
  (let ((compiland *current-compiland*)
        (kernel-function-p (kernel-function-p op))
        (use-fast-call-p (use-fast-call-p))
        thread-var)
    (declare (type compiland compiland))
    (cond (use-fast-call-p
           (cond ((and kernel-function-p
                       (eql (function-arity op) 0)
                       (function-code-address (symbol-function op)))
                  (emit-call-0 op target))
                 (kernel-function-p
                  (emit-move-function-to-register op :eax)
                  (inst :push :eax)
                  (emit-call-1 "RT_fast_call_function_0" target))
                 ((and (eq op (compiland-name compiland))
                       (eql (compiland-arity compiland) 0))
                  (emit-recurse)
                  (move-result-to-target target))
                 (t
                  (p2-symbol op :stack)
                  (emit-call-1 "RT_fast_call_symbol_0" target))))
          ;; not use-fast-call-p
          ((setq thread-var (compiland-thread-var compiland))
           (cond (kernel-function-p
                  (emit-move-function-to-register op :eax)
                  (inst :push :eax)
                  (inst :push thread-var)
                  (emit-call-2 "RT_thread_call_function_0" target))
                 (t
                  (p2-symbol op :stack)
                  (inst :push thread-var)
                  (emit-call-2 "RT_thread_call_symbol_0" target))))
          (t
           (p2-symbol op :stack)
           (emit-call-1 "RT_current_thread_call_symbol_0" target)))))

(defknown p2-function-call-1 (t t t) t)
(defun p2-function-call-1 (op args target)
  (let ((arg (%car args))
        (compiland *current-compiland*)
        (kernel-function-p (kernel-function-p op))
        (use-fast-call-p (use-fast-call-p))
        thread-var)
    (declare (type compiland compiland))
    (cond (kernel-function-p
           (cond ((and (eql (function-arity op) 1)
                       (function-code-address (symbol-function op))
                       (or use-fast-call-p
                           (memq :safe (function-attributes op))))
                  (process-1-arg arg :stack t)
                  (emit-call-1 op target))
                 (use-fast-call-p
                  (process-1-arg arg :stack t)
                  (emit-move-function-to-register op :eax)
                  (inst :push :eax)
                  (emit-call-2 "RT_fast_call_function_1" target))
                 ;; not use-fast-call-p
                 ((setq thread-var (compiland-thread-var compiland))
                  ;; RT_thread_call_function_1() calls thread->clear_values()
                  (process-1-arg arg :stack nil)
                  (emit-move-function-to-register op :eax)
                  (inst :push :eax)
                  (inst :push thread-var)
                  (emit-call-3 "RT_thread_call_function_1" target))
                 (t
                  ;; no thread register
                  ;; RT_current_thread_call_function_1() calls thread->clear_values()
                  (process-1-arg arg :stack nil)
                  (emit-move-function-to-register op :eax)
                  (inst :push :eax)
                  (emit-call-2 "RT_current_thread_call_function_1" target))))
          ;; not kernel-function-p
          (use-fast-call-p
           (cond ((and (eq op (compiland-name compiland))
                       (eql (compiland-arity compiland) 1))
                  (process-1-arg arg :stack t)
                  (emit-recurse)
                  (emit-adjust-stack-after-call 1)
                  (move-result-to-target target))
                 (t
                  (process-1-arg arg :stack t)
                  (p2-symbol op :stack)
                  (emit-call-2 "RT_fast_call_symbol_1" target))))
          ;; not use-fast-call-p
          ((setq thread-var (compiland-thread-var compiland))
           ;; RT_thread_call_symbol_1() calls thread->clear_values()
           (process-1-arg arg :stack nil)
           (p2-symbol op :stack)
           (inst :push thread-var)
           (emit-call-3 "RT_thread_call_symbol_1" target))
          ;; no thread register
          (t
           ;; RT_current_thread_call_symbol_1() calls thread->clear_values()
           (process-1-arg arg :stack nil)
           (p2-symbol op :stack)
           (emit-call-2 "RT_current_thread_call_symbol_1" target)))))

(defknown p2-function-call-2 (t t t) t)
(defun p2-function-call-2 (op args target)
  (let ((compiland *current-compiland*)
        (kernel-function-p (kernel-function-p op))
        (use-fast-call-p (use-fast-call-p))
        thread-var)
    (declare (type compiland compiland))
    (cond (kernel-function-p
           (cond ((and (eql (function-arity op) 2)
                       (function-code-address (symbol-function op))
                       (or use-fast-call-p
                           (memq :safe (function-attributes op))))
                  (process-2-args args :stack t)
                  (emit-call-2 op target))
                 (use-fast-call-p
                  (process-2-args args :stack t)
                  (emit-move-function-to-register op :eax)
                  (inst :push :eax)
                  (emit-call-3 "RT_fast_call_function_2" target))
                 ;; not use-fast-call-p
                 ((setq thread-var (compiland-thread-var compiland))
                  ;; RT_thread_call_function_2() calls thread->clear_values()
                  (process-2-args args :stack nil)
                  (emit-move-function-to-register op :eax)
                  (inst :push :eax)
                  (inst :push thread-var)
                  (emit-call-4 "RT_thread_call_function_2" target))
                 ;; no thread register
                 (t
                  ;; RT_current_thread_call_function_2() calls thread->clear_values()
                  (process-2-args args :stack nil)
                  (emit-move-function-to-register op :eax)
                  (inst :push :eax)
                  (emit-call-3 "RT_current_thread_call_function_2" target))))
          ;; not kernel-function-p
          (use-fast-call-p
           (cond ((and (eq op (compiland-name compiland))
                       (eql (compiland-arity compiland) 1))
                  (process-2-args args :stack t)
                  (emit-recurse)
                  (emit-adjust-stack-after-call 2)
                  (move-result-to-target target))
                 (t
                  (process-2-args args :stack t)
                  (p2-symbol op :eax)
                  (inst :push :eax)
                  (emit-call-3 "RT_fast_call_symbol_2" target))))
          ;; not use-fast-call-p
          ((setq thread-var (compiland-thread-var compiland))
           (process-2-args args :stack nil)
           ;; RT_thread_call_symbol_2() calls thread->clear_values()
           (p2-symbol op :eax)
           (inst :push :eax)
           (inst :push thread-var)
           (emit-call-4 "RT_thread_call_symbol_2" target))
          ;; no thread register
          (t
           (process-2-args args :stack nil)
           ;; RT_current_thread_call_symbol_2() calls thread->clear_values()
           (p2-symbol op :eax)
           (inst :push :eax)
           (emit-call-3 "RT_current_thread_call_symbol_2" target)))))

(defknown p2-function-call-3 (t t t) t)
(defun p2-function-call-3 (op args target)
  (let ((compiland *current-compiland*)
        (kernel-function-p (kernel-function-p op))
        (use-fast-call-p (use-fast-call-p))
        thread-var)
    (declare (type compiland compiland))
    (cond (kernel-function-p
           (cond ((and (eql (function-arity op) 3)
                       (function-code-address (symbol-function op))
                       (or use-fast-call-p
                           (memq :safe (function-attributes op))))
                  (process-3-args args :stack t)
                  (emit-call-3 op target))
                 (use-fast-call-p
                  (process-3-args args :stack t)
                  (emit-move-function-to-register op :eax)
                  (inst :push :eax)
                  (emit-call-4 "RT_fast_call_function_3" target))
                 ;; not use-fast-call-p
                 ((setq thread-var (compiland-thread-var compiland))
                  ;; RT_thread_call_function_3() calls thread->clear_values()
                  (process-3-args args :stack nil)
                  (emit-move-function-to-register op :eax)
                  (inst :push :eax)
                  (inst :push thread-var)
                  (emit-call-5 "RT_thread_call_function_3" target))
                 ;; no thread register
                 (t
                  ;; RT_current_thread_call_function_2() calls thread->clear_values()
                  (process-3-args args :stack nil)
                  (emit-move-function-to-register op :eax)
                  (inst :push :eax)
                  (emit-call-4 "RT_current_thread_call_function_3"))))
          ;; not kernel-function-p
          (use-fast-call-p
           (process-3-args args :stack t)
           (cond ((and (eq op (compiland-name compiland))
                       (eql (compiland-arity compiland) 3))
                  (emit-recurse)
                  (emit-adjust-stack-after-call 3)
                  (move-result-to-target target))
                 (t
                  (p2-symbol op :stack)
                  (emit-call-4 "RT_fast_call_symbol_3" target))))
          ;; not use-fast-call-p
          ((setq thread-var (compiland-thread-var compiland))
           (process-3-args args :stack nil)
           (p2-symbol op :stack)
           (inst :push thread-var)
           (emit-call-5 "RT_thread_call_symbol_3" target))
          (t
           (process-3-args args :stack nil)
           (p2-symbol op :stack)
           (emit-call-4 "RT_current_thread_call_symbol_3" target)))))

(defknown p2-function-call-4 (t t t) t)
(defun p2-function-call-4 (op args target)
  (let ((compiland *current-compiland*)
        (kernel-function-p (kernel-function-p op))
        (use-fast-call-p (use-fast-call-p))
        thread-var)
    (declare (type compiland compiland))
    (process-4-args args :stack use-fast-call-p)
    (cond (use-fast-call-p
           (cond ((and kernel-function-p
                       (eql (function-arity op) 4)
                       (function-code-address (symbol-function op)))
                  (emit-call-4 op target))
                 (kernel-function-p
                  (emit-move-function-to-register op :eax)
                  (inst :push :eax)
                  (emit-call-5 "RT_fast_call_function_4" target))
                 ((and (eq op (compiland-name compiland))
                       (eql (compiland-arity compiland) 4))
                  (emit-recurse)
                  (emit-adjust-stack-after-call 4)
                  (move-result-to-target target))
                 (t
                  (p2-symbol op :stack)
                  (emit-call-5 "RT_fast_call_symbol_4" target))))
          ;; not use-fast-call-p
          ((setq thread-var (compiland-thread-var compiland))
           (cond (kernel-function-p
                  (emit-move-function-to-register op :eax)
                  (inst :push :eax)
                  (inst :push thread-var)
                  (emit-call-6 "RT_thread_call_function_4" target))
                 (t
                  (p2-symbol op :stack)
                  (inst :push thread-var)
                  (emit-call-6 "RT_thread_call_symbol_4" target))))
          (t
           (p2-symbol op :stack)
           (emit-call-5 "RT_current_thread_call_symbol_4" target)))))

(defknown p2-function-call-5 (t t t) t)
(defun p2-function-call-5 (op args target)
  (let ((compiland *current-compiland*)
        (kernel-function-p (kernel-function-p op))
        (use-fast-call-p (use-fast-call-p))
        thread-var)
    (declare (type compiland compiland))
    (process-5-args args :stack use-fast-call-p)
    (cond (use-fast-call-p
           (cond ((and kernel-function-p
                       (eql (function-arity op) 5)
                       (function-code-address (symbol-function op)))
                  (emit-call-5 op target))
                 (kernel-function-p
                  (emit-move-function-to-register op :eax)
                  (inst :push :eax)
                  (emit-call-6 "RT_fast_call_function_5" target))
                 ((and (eq op (compiland-name compiland))
                       (eql (compiland-arity compiland) 5))
                  (emit-recurse)
                  (emit-adjust-stack-after-call 5)
                  (move-result-to-target target))
                 (t
                  (p2-symbol op :stack)
                  (emit-call-6 "RT_fast_call_symbol_5" target))))
          ;; not use-fast-call-p
          ((setq thread-var (compiland-thread-var compiland))
           (cond (kernel-function-p
                  (emit-move-function-to-register op :eax)
                  (inst :push :eax)
                  (inst :push thread-var)
                  (emit-call-7 "RT_thread_call_function_5" target))
                 (t
                  (p2-symbol op :stack)
                  (inst :push thread-var)
                  (emit-call-7 "RT_thread_call_symbol_5" target))))
          (t
           (p2-symbol op :stack)
           (emit-call-6 "RT_current_thread_call_symbol_5" target)))))

(defknown p2-function-call-6 (t t t) t)
(defun p2-function-call-6 (op args target)
  (let ((compiland *current-compiland*)
        (kernel-function-p (kernel-function-p op))
        (use-fast-call-p (use-fast-call-p))
        thread-var)
    (declare (type compiland compiland))
    (process-6-args args :stack use-fast-call-p)
    (cond (use-fast-call-p
           (cond ((and kernel-function-p
                       (eql (function-arity op) 6)
                       (function-code-address (symbol-function op)))
                  (emit-call-6 op target))
                 ((and (eq op (compiland-name compiland))
                       (eql (compiland-arity compiland) 6))
                  (emit-recurse)
                  (inst :add #x18 :esp)
                  (move-result-to-target target))
                 (t
                  (p2-symbol op :stack)
                  (emit-call-7 "RT_fast_call_symbol_6" target))))
          ;; not use-fast-call-p
          ((setq thread-var (compiland-thread-var compiland))
           (cond (kernel-function-p
                  (emit-move-function-to-register op :eax)
                  (inst :push :eax)
                  (inst :push thread-var)
                  (emit-call-8 "RT_thread_call_function_6" target))
                 (t
                  (p2-symbol op :stack)
                  (inst :push thread-var)
                  (emit-call-8 "RT_thread_call_symbol_6" target))))
          (t
           (p2-symbol op :stack)
           (emit-call-7 "RT_current_thread_call_symbol_6" target)))))

(defknown p2-local-function-call (t t) t)
(defun p2-local-function-call (form target)
  (declare (type cons form))
  (let* ((op (car form))
         (args (cdr form))
         (numargs (length args))
         (compiland *current-compiland*)
         (thread-var (compiland-thread-var compiland))
         (closure-data-index (compiland-closure-data-index compiland))
         (local-function (find-local-function op))
         (use-fast-call-p (use-fast-call-p)))
    (declare (type compiland compiland))
    (declare (type local-function local-function))
    (mumble "p2-local-function-call called compiland = ~S~%" (compiland-name compiland))
    (aver local-function)
;;     (aver thread-var)
    (unless (<= 0 numargs 6)
      (compiler-unsupported "P2-LOCAL-FUNCTION-CALL numargs = ~D not supported" numargs))
    (when args
      (process-args args :stack use-fast-call-p))

    (when (and use-fast-call-p
               (eq (local-function-compiland local-function) compiland)
               (eql numargs (compiland-arity compiland)))
      (mumble "p2-local-function-call optimized recursive call~%")
      (emit-move-local-to-register closure-data-index :eax)
      (inst :push :eax)
      (emit-recurse)
      (emit-adjust-stack-after-call (1+ numargs))
      (move-result-to-target target)
      (return-from p2-local-function-call))

    (cond ((local-function-callable-name local-function)
           (mumble "p2-local-function-call local-function-callable-name case~%")
           (emit-move-function-to-register (local-function-callable-name local-function) :eax)
           (clear-register-contents :eax)
           (inst :push :eax))
          ((local-function-function local-function)
           (mumble "p2-local-function-call local-function-function case~%")
           (emit-move-immediate (local-function-function local-function) :eax)
           (clear-register-contents :eax)
           (inst :push :eax))
          ((local-function-var local-function)
           (mumble "p2-local-function-call var ref case~%")
           (aver (local-function-var local-function))
           (p2-var-ref (make-var-ref (local-function-var local-function)) :stack)
           )
;;           ((local-function-callable-name local-function)
;;            (p2-constant (local-function-callable-name local-function) :stack)
;;            (emit-call-1 'symbol-function :stack))
          ((compile-file-p)
           (cond ((local-function-ctf-name local-function)
                  (emit-move-local-to-register closure-data-index :edx)
                  (emit-move-function-to-register (local-function-ctf-name local-function) :eax)
                  (inst :push :edx)
                  (inst :push :eax)
                  (emit-call-2 "RT_make_compiled_closure" :stack))
                 (t
                  (aver (local-function-callable-name local-function))
                  (emit-move-function-to-register (local-function-callable-name local-function) :eax)
                  (inst :push :eax))))
;;           ((local-function-ctf local-function)
;;            (emit-move-local-to-register closure-data-index :eax)
;;            (inst :push :eax)
;;            (emit-push-immediate (local-function-ctf local-function))
;;            (emit-call-2 "RT_make_compiled_closure" :stack))
          (t
           (aver nil)
           (emit-push-immediate (local-function-function local-function))))
    (cond (use-fast-call-p
           (emit-call-n (format nil "RT_fast_call_function_~D" numargs)
                        target  (+ 1 numargs)))
          (t
           (aver thread-var)
           (inst :push thread-var)
           (emit-call-n (format nil "RT_thread_call_function_~D" numargs)
                        target (+ 2 numargs))))))

(defknown p2-function-call-n (t t t t) t)
(defun p2-function-call-n (numargs op args target)
  (aver (< 0 numargs call-arguments-limit)) ; FIXME compiler-error
  (let ((size (* numargs +bytes-per-word+))
        (index 0)
        thread-var)
    (inst :sub size :esp)
    (dolist (arg args)
      (p2 arg :eax)
      (inst :mov :eax `(,index :esp))
      (incf index +bytes-per-word+))
    (when (use-fast-call-p)
      (dolist (arg args)
        (unless (single-valued-p arg)
          (emit-clear-values)
          (return))))
    (inst :push :esp)
    (inst :push numargs)
    (p2-symbol op :stack)
    (cond ((use-fast-call-p)
           (emit-call-3 "RT_fast_call_symbol" :eax))
          ((setq thread-var (compiland-thread-var *current-compiland*))
           (inst :push thread-var)
           (emit-call-4 "RT_thread_call_symbol" :eax))
          (t
           (emit-call-3 "RT_current_thread_call_symbol" :eax)))
    (inst :add size :esp)
    (move-result-to-target target)))

(defknown p2-symbol-global-value (t t) t)
(defun p2-symbol-global-value (form target)
  (when (check-arg-count form 1)
    (let* ((arg (%cadr form))
           (type (derive-type arg))
           (LABEL (make-label)))
      (when (eq type 'SYMBOL)
        (process-1-arg arg :eax t)
        (clear-register-contents :eax)
        (inst :compare-immediate nil :eax)
        (emit-jmp-short :e LABEL)
        (let ((displacement (- +symbol-value-offset+ +symbol-lowtag+)))
          (inst :mov `(,displacement :eax) :eax))
        (label LABEL)
        (move-result-to-target target)
        t))))

(defknown p2-symbol-name (t t) t)
(defun p2-symbol-name (form target)
  (when (check-arg-count form 1)
    (let* ((arg (%cadr form))
           (type (derive-type arg))
           (LABEL1 (make-label))
           (LABEL2 (make-label)))
      (when (eq type 'SYMBOL)
        (process-1-arg arg :eax t)
        (clear-register-contents :eax)
        (inst :compare-immediate nil :eax)
        (emit-jmp-short :e LABEL1)
        (let ((displacement (- +symbol-name-offset+ +symbol-lowtag+)))
          (inst :mov `(,displacement :eax) :eax))
        (inst :add +typed-object-lowtag+ :eax)
        (move-result-to-target target)
        (emit-jmp-short t LABEL2)
        (label LABEL1)
        (p2-constant +nil-symbol-name+ target)
        (label LABEL2)
        t))))

(defknown p2-symbol-package (t t) t)
(defun p2-symbol-package (form target)
  (when (check-arg-count form 1)
    (let* ((arg (%cadr form))
           (type (derive-type arg))
           (LABEL1 (make-label))
           (LABEL2 (make-label)))
      (when (eq type 'SYMBOL)
        (process-1-arg arg :eax t)
        (clear-register-contents :eax)
        (inst :compare-immediate nil :eax)
        (emit-jmp-short :e LABEL1)
        (let ((displacement (- +symbol-package-offset+ +symbol-lowtag+)))
          (inst :mov `(,displacement :eax) :eax))
        (move-result-to-target target)
        (emit-jmp-short t LABEL2)
        (label LABEL1)
        (p2-constant +common-lisp-package+ target)
        (label LABEL2)
        t))))

(defknown p2-var-ref (t t) t)
(defun p2-var-ref (form target)
  (declare (type var-ref form))
  (when (null target)
    ;; nothing to do
    (return-from p2-var-ref))
  (unless (or (memq target '(:stack :return))
              (eql (register-bit-size target) 32))
    (error "unsupported target ~S" target))
  (let ((var (var-ref-var form)))
    (declare (type var var))
    (cond ((var-constant-p var)
           (p2-constant (var-constant-value var) target))
          ((var-special-p var)
           (let ((name (var-name var)))
             (cond ((constantp name)
                    ;; REVIEW
                    (let ((value (symbol-value name)))
                      (cond  ((or (not (compile-file-p))
                                  (integerp value)
                                  (characterp value)
                                  (stringp value))
                              (p2-constant value target))
                             (t
                              (p2-symbol-global-value `(symbol-global-value ',name) target)))))
                   ((compiland-thread-var *current-compiland*)
                    (p2-symbol name :stack)
                    (inst :push (compiland-thread-var *current-compiland*))
                    (emit-call-2 "RT_thread_symbol_value" target))
                   (t
                    (note "P2-VAR-REF: emitting call to RT_current_thread_symbol_value~%")
                    (p2-symbol name :stack)
                    (emit-call-1 "RT_current_thread_symbol_value" target)))))
          ((var-closure-index var)
           (emit-move-closure-var-to-register var :eax *current-compiland*)
           (move-result-to-target target)
           (when (reg32-p target)
             (set-register-contents target var)))
          (t
           (let ((reg (find-register-containing-var var)))
             (if reg
                 (case target
                   (:stack
                    (inst :push reg))
                   (:return
                    (unless (eq reg :eax)
                      (inst :mov reg :eax))
                    (inst :exit))
                   (t
                    (aver (reg32-p target))
                    (unless (eq reg target)
                      (inst :mov reg target)
                      (set-register-contents target var))))
                 (case target
                   (:stack
                    (inst :push var))
                   (:return
                    (inst :mov var :eax)
                    (inst :exit))
                   (t
                    (aver (reg32-p target))
                    (inst :mov var target)
                    (set-register-contents target var)))))))))

(defun p2-setq (form target)
  (aver (length-eql form 3))
  (let* ((args (%cdr form))
         (name (%car args))
         (value-form (%cadr args))
         (var (find-visible-var name))
         thread-var
         derived-type)
    (cond ((or (null var)
               (var-special-p var))
           (process-1-arg value-form :stack t)
           (p2-constant name :stack)
           (cond ((setq thread-var (compiland-thread-var *current-compiland*))
                  (inst :push thread-var)
                  (emit-call-3 "RT_thread_set_symbol_value" :eax))
                 (t
                  (emit-call-2 "RT_current_thread_set_symbol_value" :eax))))
          ((var-closure-index var)
           (process-1-arg value-form :eax t)
           (inst :push :eax)
           (emit-move-register-to-closure-var :eax var *current-compiland*)
           (inst :pop :eax))
          (t
           (setq derived-type (derive-type value-form))
           (process-1-arg value-form :eax t)
           (inst :mov :eax var)
           (clear-var-registers var)
           (set-register-contents :eax var)))
    (when var
      (remove-constraints var)
      (unless (var-special-p var)
        (when (and derived-type (neq derived-type :unknown))
          (add-type-constraint var derived-type))))
    (move-result-to-target target)))

(defun p2-two-arg-numeric-comparison (form target)
  (declare (type cons form))
  (let* ((op (%car form))
         (args (%cdr form))
         (arg1 (car args))
         (arg2 (cadr args))
         (type1 (derive-type arg1))
         (type2 (derive-type arg2))
         (NO (make-label))
         (FULL-CALL (make-label))
         (EXIT (make-label)))
    (when (length-eql args 2)
      (process-2-args args '(:eax :edx) t)
      (unless (fixnum-type-p type1)
        (inst :test +fixnum-tag-mask+ :al)
        (emit-jmp-short :nz FULL-CALL))
      (unless (fixnum-type-p type2)
        (inst :test +fixnum-tag-mask+ :dl)
        (emit-jmp-short :nz FULL-CALL))
      ;; falling through, both args are fixnums
      (inst :cmp :edx :eax)
      (emit-jmp-short (ecase op
                        (two-arg-< :nl)
                        (two-arg-> :ng)
                        (two-arg-<= :g)
                        (two-arg->= :l))
                      NO)
      (p2-symbol t :eax)
      (clear-register-contents :eax)
      (emit-jmp-short t EXIT)
      (label NO)
      (p2-symbol nil :eax)
      (unless (and (fixnum-type-p type1) (fixnum-type-p type2))
        (emit-jmp-short t exit)
        (label FULL-CALL)
        (inst :push :edx)
        (inst :push :eax)
        (emit-call op)
        (emit-adjust-stack-after-call 2))
      (label EXIT)
      (move-result-to-target target)
      t)))

(defknown p2-- (t t) t)
(defun p2-- (form target)
  (let* ((args (cdr form))
         (numargs (length args)))
    (cond ((eql numargs 1)
           ;; unary minus
           (let* ((arg1 (%car args))
                  (type1 (derive-type arg1))
                  (result-type (derive-type form)))
             (cond ((and (fixnum-type-p type1)
                         (fixnum-type-p result-type))
                    (mumble "p2-- optimized case~%")
                    (process-1-arg arg1 :eax t)
                    (inst :neg :eax)
                    (clear-register-contents :eax)
                    (move-result-to-target target)
                    t)
                   (t
                    nil))))
          (t
           nil))))

(defun p2-two-arg-- (form target)
  (let ((args (cdr form)))
    (when (length-eql args 2)
      (let* ((arg1 (%car args))
             (arg2 (%cadr args))
             (type1 (derive-type arg1))
             (type2 (derive-type arg2))
             (result-type (derive-type form))
             (OVERFLOW (make-label))
             (FULL-CALL (make-label))
             (EXIT (make-label)))
        (cond ((and (fixnum-type-p type1)
                    (fixnump arg2)
                    (fixnum-type-p result-type))
               (process-1-arg arg1 :eax t)
               (emit-byte #x2d) ; subtract immediate dword from eax
               (emit-dword arg2) ; arg2 is a fixnum literal
               (clear-register-contents :eax)
               (move-result-to-target target))
              ((and (fixnum-type-p type1)
                    (fixnum-type-p type2))
               (process-2-args args '(:eax :edx) t)
               (unless (fixnum-type-p result-type)
                 (inst :mov :eax :ecx) ; copy arg1 to ecx in case we need to do a full call
                 (clear-register-contents :ecx))
               (inst :sub :edx :eax)
               (clear-register-contents :eax)
               (unless (fixnum-type-p result-type)
                 (emit-jmp-short :no EXIT) ; no overflow, we're done
                 ;; push arg2 first
                 (inst :push :edx)
                 (inst :push :ecx)
                 (emit-call-2 'two-arg-- :eax)
                 (label EXIT))
               (move-result-to-target target))
              ((fixnump arg2)
               (process-1-arg arg1 :eax t)
               (inst :mov :eax :edx)
               (clear-register-contents :edx)
               (inst :test +fixnum-tag-mask+ :al)
               (emit-jmp-short :nz FULL-CALL)
               ;; falling through, arg1 is a fixnum
               (emit-byte #x2d) ; subtract immediate dword from eax
               (emit-dword arg2) ; arg2 is a fixnum literal
               (clear-register-contents :eax)
               (emit-jmp-short :no EXIT) ; no overflow, we're done
               (label FULL-CALL)
               ;; push arg2 first
               (emit-push-immediate arg2) ; arg2 is a fixnum literal
               ;; arg1 is already in edx
               (inst :push :edx)
               (emit-call-2 'two-arg-- :eax)
               (label EXIT)
               (move-result-to-target target))
              ((or (float-type-p type1)
                   (float-type-p type2))
               (cond ((and (subtypep type1 'DOUBLE-FLOAT)
                           (subtypep type2 'DOUBLE-FLOAT))
                      (mumble "p2-two-arg-- double-float case~%")
                      (process-2-args args :stack t)
                      (emit-call-2 '%double-float-- target))
                     (t
                      ;; full call
                      (mumble "p2-two-arg-- float case~%")
                      (process-2-args args :stack t)
                      (emit-call-2 'two-arg-- target))))
              (t
               (mumble "p2-two-arg-- default case~%")
               (process-2-args args '(:eax :edx) t)
               ;; arg1 in eax, arg2 in edx
               (unless (fixnum-type-p type1)
                 (inst :test +fixnum-tag-mask+ :al)
                 (emit-jmp-short :nz FULL-CALL))
               (unless (fixnum-type-p type2)
                 (inst :test +fixnum-tag-mask+ :dl)
                 (emit-jmp-short :nz FULL-CALL))
               ;; falling through, both args are fixnums
               (inst :mov :eax :ecx) ; we're about to trash eax
               (clear-register-contents :ecx)
               (inst :sub :edx :eax)
               (clear-register-contents :eax)
               (case target
                 (:return
                  (emit-jmp-short :o OVERFLOW)
                  ;; falling through: no overflow, we're done
                  (inst :exit)
                  (label OVERFLOW))
                 (t
                  ;; if no overflow, we're done
                  (emit-jmp-short :no EXIT)))
               (inst :mov :ecx :eax)
               (label FULL-CALL)
               (inst :push :edx)
               (inst :push :eax)
               (emit-call-2 'two-arg-- :eax)
               (label EXIT)
               (move-result-to-target target))))
      t)))

(defun p2-two-arg-+ (form target)
  (let ((args (cdr form)))
    (when (eql (length args) 2)
      (let* ((arg1 (car args))
             (arg2 (cadr args))
             (type1 (derive-type arg1))
             (type2 (derive-type arg2))
             (result-type (derive-type form))
             (OVERFLOW (make-label))
             (FULL-CALL (make-label))
             (EXIT (make-label)))
        ;;       (mumble "type1 = ~S type2 = ~S result-type = ~S~%"
        ;;               type1 type2 result-type)
        (cond ((and (integer-constant-value type1)
                    (integer-constant-value type2)
                    (flushable arg1)
                    (flushable arg2))
               (p2-constant (two-arg-+ (integer-constant-value type1) (integer-constant-value type2))
                            target))
              ((and (fixnum-type-p type1)
                    (fixnump arg2)
                    (fixnum-type-p result-type))
               ;; a very common special case: (INCF X) where X is of type INDEX
               (p2 arg1 :eax)
               (unless (single-valued-p arg1)
                 (emit-clear-values :preserve :eax))
               (emit-byte #x05)                     ; add immediate dword from eax
               (emit-dword arg2)                    ; arg2 is a fixnum literal
               (clear-register-contents :eax)
               (move-result-to-target target))
              ((fixnump arg2)
               ;; as in (+ n 2), for example
               (p2 arg1 :eax)
               (unless (single-valued-p arg1)
                 (emit-clear-values :preserve :eax))
               (inst :mov :eax :edx)
               (clear-register-contents :edx)
               (unless (fixnum-type-p type1)
                 (inst :test +fixnum-tag-mask+ :al)
                 (emit-jmp-short :nz FULL-CALL))
               ;; falling through, arg1 is a fixnum
               (let ((n (ash arg2 +fixnum-shift+)))
                 (cond ((typep n '(signed-byte 8))
                        (inst :add n :eax))
                       (t
                        (emit-byte #x05) ; add immediate dword from eax
                        (emit-dword arg2) ; arg2 is a fixnum literal
                        )))
               (clear-register-contents :eax)
               (emit-jmp-short :o FULL-CALL)
               (label EXIT)
               (move-result-to-target target)
               (let ((*current-segment* :elsewhere))
                 (label FULL-CALL)
                 ;; push arg2 first
                 (inst :push (ash arg2 +fixnum-shift+))
                 ;; arg1 is already in edx
                 (inst :push :edx)
                 (emit-call 'two-arg-+)
                 (emit-adjust-stack-after-call 2)
                 (emit-jmp-short t EXIT)))
              ((or (float-type-p type1)
                   (float-type-p type2))
               (cond ((and (subtypep type1 'DOUBLE-FLOAT)
                           (subtypep type2 'DOUBLE-FLOAT))
                      (process-2-args args :stack t)
                      (emit-call-2 '%double-float-+ target))
                     (t
                      ;; full call
                      (process-2-args args :stack t)
                      (emit-call-2 'two-arg-+ target))))
              (t
               (process-2-args args '(:eax :edx) t)
               ;; arg1 in eax, arg2 in edx
               (unless (fixnum-type-p type1)
                 (inst :test +fixnum-tag-mask+ :al)
                 (emit-jmp-short :nz FULL-CALL))
               (unless (fixnum-type-p type2)
                 (inst :test +fixnum-tag-mask+ :dl)
                 (emit-jmp-short :nz FULL-CALL))
               ;; falling through, both args are fixnums
               (unless (fixnum-type-p result-type)
                 (inst :mov :eax :ecx) ; we're about to trash eax
                 (clear-register-contents :ecx))
               (inst :add :edx :eax)
               (clear-register-contents :eax)
               (case target
                 (:return
                  (emit-jmp-short :o OVERFLOW)
                  ;; falling through: no overflow, we're done
                  (inst :exit)
                  (label OVERFLOW))
                 (t
                  ;; if no overflow, we're done
                  (emit-jmp-short :no EXIT)))
               (inst :mov :ecx :eax)
               (label FULL-CALL)
               (inst :push :edx)
               (inst :push :eax)
               (emit-call-2 'two-arg-+ :eax)
               (label EXIT)
               (move-result-to-target target))))
      t)))

(defun p2-two-arg-* (form target)
  (let ((args (cdr form)))
    (when (length-eql args 2)
      (let* ((arg1 (%car args))
             (arg2 (%cadr args)))
        (when (and (numberp arg1)
                   (numberp arg2))
          (p2-constant (two-arg-* arg1 arg2) target)
          (return-from p2-two-arg-* t))
        (when (numberp arg1)
          (let ((temp arg1))
            (setq arg1 arg2
                  arg2 temp
                  args (list arg1 arg2))))
        (let* ((type1 (derive-type arg1))
               (type2 (derive-type arg2)))
          (cond ((and (integer-constant-value type1)
                      (integer-constant-value type2)
                      (flushable arg1)
                      (flushable arg2))
                 (p2-constant (two-arg-* (integer-constant-value type1) (integer-constant-value type2))
                              target)
                 (return-from p2-two-arg-* t))
                ((or (float-type-p type1)
                     (float-type-p type2))
                 ;; full call
                 (process-2-args args :stack t)
                 (emit-call-2 'two-arg-* target)
                 (return-from p2-two-arg-* t)))
          (let* ((OVERFLOW (make-label))
                 (FULL-CALL (make-label))
                 (EXIT (make-label)))
            (cond (t
                   (process-2-args args '(:eax :edx) t)
                   ;; arg1 in eax, arg2 in edx
                   (unless (fixnum-type-p type1)
                     (inst :test +fixnum-tag-mask+ :al)
                     (emit-jmp-short :nz FULL-CALL))
                   (unless (fixnum-type-p type2)
                     (inst :test +fixnum-tag-mask+ :dl)
                     (emit-jmp-short :nz FULL-CALL))
                   ;; falling through, both args are fixnums
                   (inst :mov :eax :ecx) ; we're about to trash :eax
                   ;;              (emit-bytes #x01 #xd0) ; add %edx,%eax
                   (emit-bytes #xc1 #xf8 #x02) ; sar $0x2,%eax
                   (emit-bytes #x0f #xaf #xc2) ; imul %edx,%eax
                   (case target
                     (:return
                      (emit-jmp-short :o OVERFLOW)
                      ;; falling through: no overflow, we're done
                      (inst :exit)
                      (label OVERFLOW))
                     (t
                      ;; if no overflow, we're done
                      (emit-jmp-short :no EXIT)))
                   (inst :mov :ecx :eax)
                   (label FULL-CALL)
                   (inst :push :edx)
                   (inst :push :eax)
                   (emit-call 'two-arg-*)
                   (emit-adjust-stack-after-call 2)
                   (label EXIT)
                   (move-result-to-target target)
                   t))))))))

(defknown p2-mod (t t) t)
(defun p2-mod (form target)
  (when (check-arg-count form 2)
    (let* ((args (%cdr form))
           (arg1 (%car args))
           (arg2 (%cadr args))
           (type1 (derive-type arg1))
           (type2 (derive-type arg2)))
      (cond ((and (subtypep type1 'unsigned-byte)
                  (subtypep type2 'unsigned-byte))
             (let ((FULL-CALL (make-label))
                   (EXIT (make-label)))
               (process-2-args args '(:eax :ecx) t)
               ;; number in eax, divisor in ecx
               (unless (fixnum-type-p type1)
                 (inst :test +fixnum-tag-mask+ :al)
                 (emit-jmp-short :nz FULL-CALL))
               (unless (fixnum-type-p type2)
                 (inst :test +fixnum-tag-mask+ :cl)
                 (emit-jmp-short :nz FULL-CALL))
               ;; falling through, both args are fixnums
               (unless (and (neq type2 :unknown)
                            (not (typep 0 type2)))
                 ; handle division by zero
                 (inst :test :ecx :ecx)
                 (emit-jmp-short :z FULL-CALL))
               (let ((divisor (integer-constant-value type2)))
                 (case divisor
                   ((2 4 8 16 32 64 128 256)
                    (inst :and (fixnumize (1- divisor)) :eax))
                   (t
                    (inst :xor :edx :edx)
                    (emit-bytes #xf7 #xf1) ; div %ecx
                    (clear-register-contents :eax :ecx :edx)
                    ;; remainder is in edx
                    (inst :mov :edx :eax))))
               (unless (and (fixnum-type-p type1)
                            (fixnum-type-p type2)
                            (not (typep 0 type2)))
                 (emit-jmp-short t EXIT)
                 (label FULL-CALL)
                 (inst :push :ecx)
                 (inst :push :eax)
                 (emit-call-2 'mod :eax)
                 (label EXIT))
               (move-result-to-target target)))
            (t
             (mumble "p2-mod full call type1 = ~S type2 = ~S~%" type1 type2)
             (process-2-args args :default t)
             (emit-call-2 'mod target)
             t)))))

(defun p2-min/max (form target)
  (let* ((op (car form))
         (args (cdr form)))
    (when (length-eql args 2)
      (let* ((arg1 (%car args))
             (arg2 (%cadr args))
             (type1 (derive-type arg1))
             (type2 (derive-type arg2)))
        (process-2-args args '(:eax :edx) t)
        ;; arg1 in eax, arg2 in edx
        (let ((FULL-CALL (make-label))
              (EXIT (make-label)))
          (unless (fixnum-type-p type1)
            (inst :test +fixnum-tag-mask+ :al)
            (emit-jmp-short :nz FULL-CALL))
          (unless (fixnum-type-p type2)
            (inst :test +fixnum-tag-mask+ :dl)
            (emit-jmp-short :nz FULL-CALL))
          ;; falling through, both args are fixnums
          (inst :cmp :edx :eax)
          (emit-jmp-short (ecase op
                            ((min two-arg-min) :l)
                            ((max two-arg-max) :g))
                          EXIT)
          (inst :mov :edx :eax)
          (clear-register-contents :eax)
          (unless (and (fixnum-type-p type1)
                       (fixnum-type-p type2))
            (emit-jmp-short t EXIT)
            (label FULL-CALL)
            (inst :push :edx)
            (inst :push :eax)
            (emit-call-2 op :eax))
          (label EXIT)
          (move-result-to-target target)))
      t)))

(defun p2-gethash (form target)
  (let* ((op (car form))
         (args (cdr form))
         (arg2 (second args))
         (type2 (derive-type arg2))
         (numargs (length args))
         thread-var)
    (cond ((and (eq type2 :unknown)
                (not (zerop *safety*)))
           nil)
          ((or (zerop *safety*)
               (subtypep type2 'HASH-TABLE))
           (case numargs
             (2
              (process-2-args args :stack t)
              (ecase op
                (gethash2-1
                 (emit-call-2 '%gethash2-1 target))
                (gethash2
                 (cond ((setq thread-var (compiland-thread-var *current-compiland*))
                        (inst :push thread-var)
                        (emit-call-3 "RT_gethash2" target))
                       (t
                        (emit-call-2 op target)))))
              t)
             (3
              (process-3-args args :stack t)
              (cond ((setq thread-var (compiland-thread-var *current-compiland*))
                     (inst :push thread-var)
                     (emit-call-4 "RT_gethash3" target))
                    (t
                     (emit-call-3 'gethash3 target)))
              t)
             (t
              ;; wrong number of arguments
              nil)))
          (t
           ;; error
           nil))))

(defun p2-ash (form target)
  (when (check-arg-count form 2)
    (let* ((args (%cdr form))
           (arg1 (%car args))
           (arg2 (%cadr args))
           type1
           type2
           result-type
           shift)
      (when (null target)
        (p2 arg1 nil)
        (p2 arg2 nil)
        (maybe-emit-clear-values arg1 arg2)
        (return-from p2-ash t))
      (when (and (integerp arg1) (integerp arg2))
        (p2-constant (ash arg1 arg2) target)
        (return-from p2-ash t))
      (setq type1 (derive-type arg1)
            type2 (derive-type arg2)
            result-type (derive-type form)
            shift (integer-constant-value type2))
      (cond ((and (integer-constant-value type1)
                  shift)
             (let ((must-clear-values nil))
               (unless (flushable arg1)
                 (p2 arg1 nil)
                 (unless (single-valued-p arg1)
                   (setq must-clear-values t)))
               (unless (flushable arg2)
                 (p2 arg2 nil)
                 (unless (single-valued-p arg2)
                   (setq must-clear-values t)))
               (when must-clear-values
                 (emit-clear-values)))
             (p2-constant (ash (integer-constant-value type1) shift) target)
             t)
            ((and (eql shift 0)
                  (flushable arg2)
                  (or (integer-type-p type1)
                      (zerop *safety*)))
             (p2 arg1 target)
             (unless (single-valued-p arg1)
               (emit-clear-values :preserve target))
             t)
            ((and (eql (integer-constant-value type1) 0)
                  (or (integer-type-p type2)
                      (zerop *safety*)))
             (unless (flushable arg1)
               (p2 arg1 nil))
             (unless (flushable arg2)
               (p2 arg2 nil))
             (p2-constant 0 target)
             t)
            ((and (fixnum-type-p type1)
                  (fixnum-type-p type2)
                  (fixnum-type-p result-type))
             (cond ((and shift
                         (< shift 0)
                         (> shift -32))
                    (cond ((flushable arg2)
                           (process-1-arg arg1 :eax t)
                           (inst :sar (- shift) :eax)
                           (clear-register-contents :eax))
                          (t
                           (process-2-args args '(:eax :ecx) t)
                           (unbox-fixnum :ecx)
                           (emit-bytes #xf7 #xd9) ; neg %ecx
                           (emit-bytes #xd3 #xf8) ; sar %cl,%eax
                           (clear-register-contents :eax :ecx)))
                    ;; clear tag bits
                    (inst :and #xfc :al)
                    (move-result-to-target target)
                    t)
                   ((and shift
                         (>= shift 0)
                         (< shift 32))
                    (cond ((flushable arg2)
                           (process-1-arg arg1 :eax t)
                           (unless (eql shift 0)
                             (inst :shl shift :eax)
                             (clear-register-contents :eax)))
                          (t
                           (process-2-args args '(:eax :ecx) t)
                           (unbox-fixnum :ecx)
                           (emit-bytes #xd3 #xe0) ; shl %cl,%rax
                           (clear-register-contents :eax :ecx)))
                    (move-result-to-target target)
                    t)
                   (t
                    (mumble "p2-ash full call 1 type1 = ~S type2 = ~S result-type = ~S~%"
                            type1 type2 result-type)
                    (process-2-args args :stack t)
                    (emit-call-2 'ash target)
                    t)))
            ((and (subtypep type1 '(unsigned-byte 32))
                  (fixnum-type-p type2)
                  (fixnum-type-p result-type))
             (cond ((and shift
                         (< shift 0)
                         (> shift -32)
                         (flushable arg2))
                    (let ((EXIT (make-label))
                          (NOT-FIXNUM (make-label)))
                      (process-1-arg arg1 :eax t)
                      (inst :test +fixnum-tag-mask+ :al)
                      (emit-jmp-short :nz NOT-FIXNUM)
                      (cond ((> (- shift +fixnum-shift+) -32)
                             (inst :shr (- (- shift +fixnum-shift+)) :eax))
                            (t
                             (unbox-fixnum :eax)
                             (inst :shr (- shift) :eax)))
                      (box-fixnum :eax)
                      (emit-jmp-short t EXIT)
                      (label NOT-FIXNUM)
                      (inst :push :eax)
                      (emit-call-1 "RT_unsigned_byte_to_raw_ub32" :eax)
                      (inst :shr (- shift) :eax)
                      (box-fixnum :eax)
                      (label EXIT)
                      (move-result-to-target target))
                    t)
                   (t
                    (mumble "p2-ash full call 2 type1 = ~S type2 = ~S result-type = ~S~%"
                            type1 type2 result-type)
                    (process-2-args args :stack t)
                    (emit-call-2 'ash target)
                    t)))
            (t
             (mumble "p2-ash full call 3 type1 = ~S type2 = ~S result-type = ~S~%"
                     type1 type2 result-type)
             (process-2-args args :stack t)
             (emit-call-2 'ash target)
             t)))))

(defun p2-logior/logxor (form target)
  (let ((args (cdr form)))
    (when (length-eql args 2)
      (let* ((op (%car form))
             (arg1 (%car args))
             (arg2 (%cadr args))
             type1
             type2
             (FULL-CALL (gensym))
             (EXIT (gensym))
             thread-var)
        (when (fixnump arg1)
          (let ((temp arg1))
            (setq arg1 arg2
                  arg2 temp))
          (setq args (list arg1 arg2)))
        (setq type1 (derive-type arg1)
              type2 (derive-type arg2))
;;         (mumble "p2-logior/logxor type1 = ~S type2 = ~S~%" type1 type2)
        (cond ((and (eql arg2 0)
                    (integer-type-p type1))
;;                (mumble "p2-logior/logxor arg2 is 0~%")
               (process-1-arg arg1 :eax t)
               (move-result-to-target target))
              ((and (eql (integer-constant-value type1) 0)
                    (integer-type-p type2))
               (unless (flushable arg1)
                 (p2 arg1 nil)
                 (unless (single-valued-p arg1)
                   (emit-clear-values)))
               (process-1-arg arg2 :eax t)
               (move-result-to-target target))
              ((and (eql (integer-constant-value type2) 0)
                    (integer-type-p type1))
               (cond ((flushable arg2)
                      (process-1-arg arg1 :eax t)
                      (move-result-to-target target))
                     (t
                      (process-1-arg arg1 :stack t)
                      (p2 arg2 nil)
                      (unless (single-valued-p arg2)
                        (emit-clear-values))
                      (cond ((eq target :stack)
                             ; nothing to do
                             )
                            ((reg32-p target)
                             (inst :pop target)
                             (clear-register-contents target))
                            (t
                             (inst :pop :eax)
                             (clear-register-contents :eax)
                             (move-result-to-target target))))))
              (t
               (process-2-args args '(:eax :edx) t)
               ;; arg1 in eax, arg2 in edx
               (unless (fixnum-type-p type1)
                 (inst :test +fixnum-tag-mask+ :al)
                 (emit-jmp-short :nz FULL-CALL))
               (unless (fixnum-type-p type2)
                 (inst :test +fixnum-tag-mask+ :dl)
                 (emit-jmp-short :nz FULL-CALL))
               ;; falling through, both args are fixnums
               (ecase op
                 ((logior two-arg-logior)
                  (emit-bytes #x09 #xd0)) ; or %edx,%eax
                 ((logxor two-arg-logxor)
                  (emit-bytes #x31 #xd0))) ; xor %edx,%eax
               (clear-register-contents :eax)
               (cond ((eq target :return)
                      (inst :exit))
                     (t
                      (move-result-to-target target)
                      (emit-jmp-short t EXIT)))
               (label FULL-CALL)
               (unless (and (fixnum-type-p type1) (fixnum-type-p type2))
                 (let ((two-arg-op (case op
                                     (logior 'two-arg-logior)
                                     (logxor 'two-arg-logxor)
                                     (t      op))))
                   (inst :push :edx)
                   (inst :push :eax)
                   (cond ((use-fast-call-p)
                          (emit-call-2 two-arg-op target))
                         ((setq thread-var (compiland-thread-var *current-compiland*))
                          (emit-move-function-to-register two-arg-op :eax)
                          (inst :push :eax)
                          (inst :push thread-var)
                          (emit-call-4 "RT_thread_call_function_2" target))
                         (t
                          (emit-move-function-to-register two-arg-op :eax)
                          (inst :push :eax)
                          (emit-call-3 "RT_current_thread_call_function_2" target)))))
               (label EXIT))))
      t)))

(defun p2-logand (form target)
  (let ((args (cdr form)))
    (when (length-eql args 2)
      (let* ((arg1 (%car args))
             (arg2 (%cadr args))
             type1
             type2
             thread-var)
        (when (null target)
          (p2 arg1 nil)
          (p2 arg2 nil)
          (maybe-emit-clear-values arg1 arg2)
          (return-from p2-logand t))
        (when (and (integerp arg1) (integerp arg2))
          (p2-constant (logand arg1 arg2) target)
          (return-from p2-logand t))
        (setq type1 (derive-type arg1)
              type2 (derive-type arg2))
        (when (and (integer-constant-value type1)
                   (integer-constant-value type2)
                   (flushable arg1)
                   (flushable arg2))
          (p2-constant (logand (integer-constant-value type1) (integer-constant-value type2))
                       target)
          (return-from p2-logand t))

        (when (and (neq type1 :unknown)
                   (subtypep type1 'unsigned-byte)
                   (eql (integer-constant-value type2) #xffffffff)
                   (flushable arg2))
          (let ((FULL-CALL (make-label))
                (EXIT (make-label)))
            (process-1-arg arg1 :eax t)
            (inst :test +fixnum-tag-mask+ :al)
            (emit-jmp-short :nz FULL-CALL)
            (cond ((eq target :return)
                   (inst :exit))
                  (t
                   (move-result-to-target target)
                   (emit-jmp-short t EXIT)))
            (label FULL-CALL)
            (inst :push :eax)
            (emit-call-1 "RT_mod32" target)
            (label EXIT))
          (return-from p2-logand t))

        (when (and (integer-type-p type1) (integer-type-p type2))
          (when (or (subtypep type1 'bignum)
                    (subtypep type2 'bignum))
            (process-2-args args :stack t)
            (cond ((use-fast-call-p)
                   (emit-call-2 'two-arg-logand target))
                  ((setq thread-var (compiland-thread-var *current-compiland*))
                   (emit-move-function-to-register 'two-arg-logand :eax)
                   (inst :push :eax)
;;                    (inst :mov thread-var :eax)
;;                    (inst :push :eax)
                   (inst :push thread-var)
                   (emit-call-4 "RT_thread_call_function_2" target))
                  (t
                   (p2-symbol 'two-arg-logand :stack)
                   (emit-call-3 "RT_current_thread_call_symbol_2" target)))
            (return-from p2-logand t)))

        (process-2-args args '(:eax :edx) t)
        ;; arg1 in eax, arg2 in edx
        (cond ((and (fixnum-type-p type1)
                    (fixnum-type-p type2))
               (inst :and :edx :eax)
               (clear-register-contents :eax)
               (move-result-to-target target)
               t)
              (t
               (let ((FULL-CALL (make-label))
                     (EXIT (make-label)))
                 (unless (fixnum-type-p type1)
                   (inst :test +fixnum-tag-mask+ :al)
                   (emit-jmp-short :nz FULL-CALL))
                 (unless (fixnum-type-p type2)
                   (inst :test +fixnum-tag-mask+ :dl)
                   (emit-jmp-short :nz FULL-CALL))
                 ;; reaching here, both args are fixnums
                 (inst :and :edx :eax)
                 (emit-jmp-short t EXIT)
                 (label FULL-CALL)
                 (inst :push :edx)
                 (inst :push :eax)
                 (cond ((or (use-fast-call-p)
                            (and (integer-type-p type1)
                                 (integer-type-p type2)))
                        (emit-call-2 'two-arg-logand :eax))
                       ((setq thread-var (compiland-thread-var *current-compiland*))
                        (emit-move-function-to-register 'two-arg-logand :eax)
                        (inst :push :eax)
                        (inst :push thread-var)
                        (emit-call-4 "RT_thread_call_function_2" :eax))
                       (t
                        (p2-symbol 'two-arg-logand :stack)
                        (emit-call-3 "RT_current_thread_call_symbol_2" :eax)))
                 (label EXIT)
                 (move-result-to-target target))
               t))))))

(defun p2-zerop (form target)
  (when (check-arg-count form 1)
    (let* ((arg (%cadr form))
           (type (derive-type arg))
           (EXIT (make-label)))
      (process-1-arg arg :eax t)
      (inst :test :eax :eax)
      (clear-register-contents :eax)
      (cond ((and (neq type :unknown)
                  (subtypep type 'INTEGER))
             (let ((NO (gensym)))
               (emit-jmp-short :nz NO)
               (p2-symbol t :eax)
               (emit-jmp-short t EXIT)
               (label NO)
               (p2-symbol nil :eax)))
            (t
             (let ((FULL-CALL (make-label)))
               (emit-jmp-short :nz FULL-CALL)
               (p2-symbol t :eax)
               (emit-jmp-short t EXIT)
               (label FULL-CALL)
               (inst :push :eax)
               (emit-call-1 'zerop :eax))))
      (label EXIT)
      (move-result-to-target target))
    t))

(defknown p2-%char-code (t t) t)
(defun p2-%char-code (form target)
  (when (check-arg-count form 1)
    (let ((arg (%cadr form)))
      (process-1-arg arg :eax t)
      (emit-bytes #x2c +character-lowtag+) ; sub $0x6,%al
      (emit-bytes #xd1 #xe8) ; shr %eax "SHR performs an unsigned divide; the high-order bit is set to 0."
      (clear-register-contents)
      (move-result-to-target target)
      t)))

(defun p2-char-code (form target)
  (when (check-arg-count form 1)
    (cond ((zerop *safety*)
           (p2-%char-code form target))
          ((eq (derive-type (%cadr form)) 'CHARACTER)
           (p2-%char-code form target))
          (t
           nil))))

(defknown p2-%code-char (t t) t)
(defun p2-%code-char (form target)
  (when (check-arg-count form 1)
    (let ((arg (%cadr form)))
      (process-1-arg arg :eax t)
      (emit-bytes #xd1 #xe0) ; shl %eax
      (emit-bytes #x04 +character-lowtag+) ; add $0x6,%al
      (clear-register-contents)
      (move-result-to-target target)
      t)))

(defun p2-code-char (form target)
  (when (check-arg-count form 1)
    (let (type)
      (cond ((zerop *safety*)
             (p2-%code-char form target))
            ((and (neq (setq type (derive-type (%cadr form))) :unknown)
                  (subtypep type '(integer 0 #.char-code-limit)))
             (p2-%code-char form target))
            (t
             nil)))))

(defknown p2-%car (t t) t)
(defun p2-%car (form target)
  (when (check-arg-count form 1)
    (process-1-arg (%cadr form) :eax t)
    (cond ((reg32-p target)
           (inst :mov '(-1 :eax) target)
           (clear-register-contents target))
          (t
           (inst :mov '(-1 :eax) :eax)
           (clear-register-contents :eax)
           (move-result-to-target target)))
    t))

(defknown p2-car (t t) t)
(defun p2-car (form target)
  (when (zerop *safety*)
    (return-from p2-car (p2-%car form target)))
  (when (check-arg-count form 1)
    (let* ((arg (%cadr form))
           (type (derive-type arg)))
      (cond ((eq type 'LIST)
             (p2-%car form target))
            ((cons-type-p type)
             (p2-%car form target))
            (t
             (process-1-arg arg :edx t)
             (let* (;(common-labels (compiland-common-labels *current-compiland*))
                    ;(ERROR (gethash :error-not-list common-labels))
                    (ERROR (common-label-error-not-list *current-compiland* :edx))
                    )
;;                (unless ERROR
;;                  (setq ERROR (make-label))
;;                  (let ((*current-segment* :elsewhere))
;;                    (label ERROR)
;;                    (p2-symbol 'LIST :stack)
;;                    (inst :push :eax)
;;                    (emit-call-2 '%type-error nil)
;;                    (inst :exit) ; FIXME
;;                    (setf (gethash :error-not-list common-labels) ERROR)))
               (inst :mov :edx :eax)
               (inst :and +lowtag-mask+ :al)
               (inst :cmp +list-lowtag+ :al)
               (emit-jmp-short :ne ERROR)
               (cond ((reg32-p target)
                      (inst :mov '(-1 :edx) target)
                      (clear-register-contents target))
                     (t
                      (inst :mov '(-1 :edx) :eax)
                      (clear-register-contents :eax)
                      (move-result-to-target target)))
               (when (var-ref-p arg)
                 (add-type-constraint (var-ref-var arg) 'LIST))))))
    t))

(defknown p2-%cdr (t t) t)
(defun p2-%cdr (form target)
  (when (check-arg-count form 1)
    (process-1-arg (%cadr form) :eax t)
    (cond ((reg32-p target)
           (inst :mov '(3 :eax) target)
           (clear-register-contents target))
          (t
           (inst :mov '(3 :eax) :eax)
           (clear-register-contents :eax)
           (move-result-to-target target)))
    t))

(defknown p2-cdr (t t) t)
(defun p2-cdr (form target)
  (when (zerop *safety*)
    (return-from p2-cdr (p2-%cdr form target)))
  (when (check-arg-count form 1)
    (let* ((arg (%cadr form))
           (type (derive-type arg)))
      (cond ((eq type 'LIST)
             (p2-%cdr form target))
            ((cons-type-p type)
             (p2-%cdr form target))
            (t
             (process-1-arg arg :edx t)
             (let* (;(EXIT (make-label))
;;                     (common-labels (compiland-common-labels *current-compiland*))
;;                     (ERROR (gethash :error-not-list common-labels))
                    (ERROR (common-label-error-not-list *current-compiland* :edx)))
;;                (unless ERROR
;;                  (setq ERROR (make-label))
;;                  (let ((*current-segment* :elsewhere))
;;                    (label ERROR)
;;                    (p2-symbol 'LIST :stack)
;;                    (inst :push :eax)
;;                    (emit-call-2 '%type-error nil)
;;                    (inst :exit) ; FIXME
;;                    (setf (gethash :error-not-list common-labels) ERROR)))
;;                (inst :compare-immediate nil :eax)
;;                (emit-jmp-short :e EXIT)
;;                (inst :push :edx)
               (inst :mov :edx :eax)
               (inst :and +lowtag-mask+ :al)
               (inst :cmp +list-lowtag+ :al)
               (emit-jmp-short :ne ERROR)
               (cond ((reg32-p target)
                      (inst :mov '(3 :edx) target)
                      (clear-register-contents target))
                     (t
                      (inst :mov '(3 :edx) :eax)
                      (clear-register-contents :eax)
                      (move-result-to-target target)))
               (when (var-ref-p arg)
                 (add-type-constraint (var-ref-var arg) 'LIST))))))
    t))

(defknown p2-rplaca (t t) t)
(defun p2-rplaca (form target)
  (when (check-arg-count form 2)
    (let* ((args (%cdr form))
           (arg1 (%car args))
           (type1 (derive-type arg1)))
      (when (cons-type-p type1)
        (process-2-args args '(:eax :edx) t)
        (inst :mov :edx '(-1 :eax))
        (move-result-to-target target)
        t))))

(defknown p2-setcar (t t) t)
(defun p2-setcar (form target)
  (when (check-arg-count form 2)
    (let* ((args (%cdr form))
           (arg1 (%car args))
           (type1 (derive-type arg1)))
      (mumble "p2-setcar type1 = ~S~%" type1)
      (when (cons-type-p type1)
        (mumble "p2-setcar optimized case~%")
        (process-2-args args '(:edx :eax) t)
        (inst :mov :eax '(-1 :edx))
        (move-result-to-target target)
        t))))

(defknown p2-rplacd (t t) t)
(defun p2-rplacd (form target)
  (when (check-arg-count form 2)
    (let* ((op (%car form))
           (args (%cdr form))
           (arg1 (%car args)))
      (when (or (eq op '%rplacd)
                (cons-type-p (derive-type arg1)))
        (process-2-args args '(:eax :edx) t)
        (inst :mov :edx '(3 :eax))
        (move-result-to-target target)
        t))))

(defknown p2-setcdr (t t) t)
(defun p2-setcdr (form target)
  (when (check-arg-count form 2)
    (let* ((args (%cdr form))
           (arg1 (%car args))
           (type1 (derive-type arg1)))
      (mumble "p2-setcdr type1 = ~S~%" type1)
      (when (cons-type-p type1)
        (mumble "p2-setcdr optimized case~%")
        (process-2-args args '(:edx :eax) t)
        (inst :mov :eax '(3 :edx))
        (move-result-to-target target)
        t))))

(defun p2-require-boolean (form target)
  (when (check-arg-count form 1)
    (let ((arg (%cadr form))
          type)
      (cond ((zerop *safety*)
             (p2 arg target))
            ((and (neq (setq type (derive-type arg)) :unknown)
                  (subtypep type 'BOOLEAN))
             (p2 arg target))
            (t
             (mumble "p2-require-boolean target = ~S~%" target)
             (process-1-arg arg :eax t)
             (let* ((EXIT (make-label))
                    (common-labels (compiland-common-labels *current-compiland*))
                    (ERROR (gethash :error-not-boolean common-labels)))
               (unless ERROR
                 (setq ERROR (make-label))
                 (let ((*current-segment* :elsewhere))
                   (label ERROR)
                   (p2-symbol 'BOOLEAN :stack)
                   (inst :push :eax)
                   (emit-call '%type-error)
                   (inst :exit) ; FIXME
                   (setf (gethash :error-not-boolean common-labels) ERROR)))
               (inst :compare-immediate nil :eax)
               (emit-jmp-short :e EXIT)
               (inst :compare-immediate t :eax)
               (emit-jmp-short :ne ERROR)
               (label EXIT)
               (when target
                 (move-result-to-target target))))))
    t))

(defun p2-require-cons (form target)
  (when (check-arg-count form 1)
    (let ((arg (%cadr form)))
      (cond ((zerop *safety*)
             (p2 arg target))
            ((cons-type-p (derive-type arg))
             (p2 arg target))
            (t
             (process-1-arg arg :eax t)
             (let* ((common-labels (compiland-common-labels *current-compiland*))
                    (ERROR (gethash :error-not-cons common-labels)))
               (unless ERROR
                 (setq ERROR (make-label))
                 (let ((*current-segment* :elsewhere))
                   (label ERROR)
                   (p2-symbol 'CONS :stack)
                   (inst :push :eax)
                   (emit-call-2 '%type-error nil)
                   (inst :exit) ; FIXME
                   (setf (gethash :error-not-cons common-labels) ERROR)))
               (inst :compare-immediate nil :eax)
               (emit-jmp-short :e ERROR)
               (inst :push :eax)
               (inst :and +lowtag-mask+ :al)
               (inst :cmp +list-lowtag+ :al)
               (inst :pop :eax)
               (emit-jmp-short :ne ERROR)
               (when target
                 (move-result-to-target target))
               (when (var-ref-p arg)
                 (set-register-contents :eax (var-ref-var arg)))))))
    t))

(defun p2-require-character (form target)
  (when (check-arg-count form 1)
    (let ((arg (%cadr form)))
      (cond ((or (zerop *safety*)
                 (eq (derive-type arg) 'CHARACTER))
             (p2 arg target))
            (t
             (mumble "p2-require-character new case~%")
             (process-1-arg arg :eax t)
             (let* ((EXIT (make-label))
                    (common-labels (compiland-common-labels *current-compiland*))
                    (ERROR (gethash :error-not-character common-labels)))
               (unless ERROR
                 (setq ERROR (make-label))
                 (let ((*current-segment* :elsewhere))
                   (label ERROR)
                   ;; arg is in eax
                   (p2-symbol 'CHARACTER :stack)
                   (inst :push :eax)
                   (emit-call-2 '%type-error nil)
                   (inst :exit) ; FIXME
                   (setf (gethash :error-not-character common-labels) ERROR)))
               (inst :mov :al :dl)
               (clear-register-contents :edx)
               (inst :and +lowtag-mask+ :dl)
               (inst :cmp +character-lowtag+ :dl)
               (emit-jmp-short :ne ERROR)
               (label EXIT)
               (when target
                 (move-result-to-target target))))))
    t))

(defun p2-require-list (form target)
  (when (check-arg-count form 1)
    (let ((arg (%cadr form))
          type)
      (cond ((zerop *safety*)
             (p2 arg target))
            ((and (neq (setq type (derive-type arg)) :unknown)
                  (subtypep type 'LIST))
             (p2 arg target))
            (t
             (process-1-arg arg :eax t)
             (let* ((EXIT (make-label))
                    (common-labels (compiland-common-labels *current-compiland*))
                    (ERROR (gethash :error-not-list common-labels)))
               (unless ERROR
                 (setq ERROR (make-label))
                 (let ((*current-segment* :elsewhere))
                   (label ERROR)
                   (p2-symbol 'LIST :stack)
                   (inst :push :eax)
                   (emit-call-2 '%type-error nil)
                   (inst :exit) ; FIXME
                   (setf (gethash :error-not-list common-labels) ERROR)))
               (inst :compare-immediate nil :eax)
               (emit-jmp-short :e EXIT)
               (inst :push :eax)
               (inst :and +lowtag-mask+ :al)
               (inst :cmp +list-lowtag+ :al)
               (inst :pop :eax)
               (emit-jmp-short :ne ERROR)
               (label EXIT)
               (when (var-ref-p arg)
                 (set-register-contents :eax (var-ref-var arg)))
               (when target
                 (move-result-to-target target))))))
    t))

(defun p2-require-symbol (form target)
  (when (check-arg-count form 1)
    (let ((arg (%cadr form))
          type)
      (cond ((zerop *safety*)
             (p2 arg target))
            ((eq (setq type (derive-type arg)) 'SYMBOL)
             (p2 arg target))
            (t
             (process-1-arg arg :eax t)
             (let* ((EXIT (make-label))
                    (common-labels (compiland-common-labels *current-compiland*))
                    (ERROR (gethash :error-not-symbol common-labels)))
               (unless ERROR
                 (setq ERROR (make-label))
                 (let ((*current-segment* :elsewhere))
                   (label ERROR)
                   (p2-symbol 'SYMBOL :stack)
                   (inst :push :eax)
                   (emit-call-2 '%type-error nil)
                   (inst :exit) ; FIXME
                   (setf (gethash :error-not-symbol common-labels) ERROR)))
               (inst :compare-immediate nil :eax)
               (emit-jmp-short :e EXIT)
               (when target
                 (inst :push :eax))
               (inst :and +lowtag-mask+ :al)
               (inst :cmp +symbol-lowtag+ :al)
               (when target
                 (inst :pop :eax))
               (emit-jmp-short :ne ERROR)
               (label EXIT)
               (when target
                 (move-result-to-target target))))))
    t))

(defknown p2-%cadr (t t) t)
(defun p2-%cadr (form target)
  (when (check-arg-count form 1)
    (process-1-arg (%cadr form) :eax t)
    (inst :mov '(3 :eax) :eax)
    (cond ((reg32-p target)
           (inst :mov '(-1 :eax) target)
           (clear-register-contents target))
          (t
           (inst :mov '(-1 :eax) :eax)
           (clear-register-contents :eax)
           (move-result-to-target target)))
    t))

(defknown p2-%cddr (t t) t)
(defun p2-%cddr (form target)
  (when (check-arg-count form 1)
    (process-1-arg (%cadr form) :eax t)
    ;; FIXME if target is a register, do the move in one step
    (emit-bytes #x8b #x40 #x03) ; mov 0x3(%eax),%eax
    (emit-bytes #x8b #x40 #x03) ; mov 0x3(%eax),%eax
    (clear-register-contents :eax)
    (move-result-to-target target)
    t))

(defknown p2-%caddr (t t) t)
(defun p2-%caddr (form target)
  (when(check-arg-count form 1)
       (process-1-arg (%cadr form) :eax t)
       (inst :mov '(3 :eax) :eax)
       (inst :mov '(3 :eax) :eax)
       ;; FIXME if target is a register, do the move in one step
       (cond ((reg32-p target)
              (inst :mov '(-1 :eax) target)
              (clear-register-contents target))
             (t
              (inst :mov '(-1 :eax) :eax)
              (clear-register-contents :eax)
              (move-result-to-target target)))
       t))

(defun p2-length (form target)
  (when (check-arg-count form 1)
    (let* ((arg (%cadr form))
           (type (derive-type arg)))
      (cond ((vectorp arg)
             (p2-constant (length arg) target))
            ((and (quoted-form-p arg)
                  (sequencep (%cadr arg)))
             (p2-constant (length (%cadr arg)) target))
            ((and (neq type :unknown)
                  (subtypep type '(SIMPLE-ARRAY * 1)))
             (process-1-arg arg :eax t)
             (let ((displacement (- +vector-capacity-offset+ +typed-object-lowtag+)))
               (inst :mov `(,displacement :eax) :eax))
             (clear-register-contents :eax)
             (inst :shl +fixnum-shift+ :eax)
             (move-result-to-target target))
            ((and (neq type :unknown)
                  (subtypep type 'VECTOR))
             (p2 arg :stack)
             (emit-call-1 '%vector-length target))
            ((and (neq type :unknown)
                  (subtypep type 'LIST))
             (setf (car form) '%list-length)
             (p2-function-call form target))
            (t
             (p2-function-call form target)
             (when (var-ref-p arg)
               (add-type-constraint (var-ref-var arg) 'SEQUENCE)))))
    t))

(defun p2-characterp (form target)
  (when (check-arg-count form 1)
    (let ((arg (cadr form))
          (NO (gensym))
          (EXIT (gensym)))
      (process-1-arg arg :eax t)
      (inst :and +lowtag-mask+ :al)
      (clear-register-contents :eax)
      (inst :cmp +character-lowtag+ :al)
      (cond ((eq target :return)
             (emit-jmp-short :ne NO)
             (p2-symbol t :eax)
             (inst :exit)
             (label NO)
             (p2-symbol nil :eax)
             (inst :exit))
            (t
             (emit-jmp-short :ne NO)
             (p2-symbol t :eax)
             (emit-jmp-short t EXIT)
             (label NO)
             (p2-symbol nil :eax)
             (label EXIT)
             (move-result-to-target target))))
    t))

(defun p2-consp (form target)
  (when (check-arg-count form 1)
    (let* ((arg (%cadr form))
           (derived-type (derive-type arg)))
      (cond ((cons-type-p derived-type)
             (p2 arg nil) ; for effect
             (p2 t target))
            (t
             (let ((NO (make-label))
                   (EXIT (make-label)))
               (process-1-arg arg :eax t)
               (inst :compare-immediate nil :eax)
               (emit-jmp-short :e NO)
               (inst :and +lowtag-mask+ :al)
               (clear-register-contents :eax)
               (inst :cmp +list-lowtag+ :al)
               (emit-jmp-short :ne NO)
               (p2 t :eax)
               (emit-jmp-short t EXIT)
               (label NO)
               (p2 nil :eax)
               (label EXIT)
               (move-result-to-target target)))))
    t))

(defun p2-integerp (form target)
  (when (check-arg-count form 1)
    (let ((arg (%cadr form))
          (EXIT (make-label))
          (BIGNUMP (make-label)))
      (process-1-arg arg :eax t)
      (inst :test +fixnum-tag-mask+ :al)
      (emit-jmp-short :nz BIGNUMP)
      (p2-symbol t target)
      (emit-jmp-short t EXIT)
      (label BIGNUMP)
      (inst :push :eax)
      (emit-call-1 'bignump target)
      (label EXIT)
      (move-result-to-target target))
    t))

(defun p2-listp (form target)
  (when (check-arg-count form 1)
    (let* ((arg (%cadr form))
           (NO (make-label))
           (EXIT (make-label)))
      (process-1-arg arg :eax t)
      (inst :and +lowtag-mask+ :al)
      (clear-register-contents :eax)
      (inst :cmp +list-lowtag+ :al)
      (emit-jmp-short :ne NO)
      (p2 t target)
      (emit-jmp-short t EXIT)
      (label NO)
      (p2 nil target)
      (label EXIT))
    t))

(defun p2-symbolp (form target)
  (when (check-arg-count form 1)
    (let* ((arg (%cadr form))
           (YES (make-label))
           (NO (make-label))
           (EXIT (make-label)))
      (process-1-arg arg :eax t)
      (inst :compare-immediate nil :eax)
      (emit-jmp-short :e YES)
      (inst :and +lowtag-mask+ :al)
      (clear-register-contents :eax)
      (inst :cmp +symbol-lowtag+ :al)
      (emit-jmp-short :ne NO)
      (label YES)
      (p2 t target)
      (emit-jmp-short t EXIT)
      (label NO)
      (p2 nil target)
      (label EXIT))
    t))

(defknown common-label-error-not-list (t) t)
(defun common-label-error-not-list (compiland register)
  (declare (type compiland compiland))
  (declare (type keyword register))
  (let* ((common-labels (compiland-common-labels compiland))
         (key (intern (concatenate 'string "ERROR-NOT-LIST-" (symbol-name register))))
         (label (gethash key common-labels)))
    (unless label
      (setq label (make-label))
      (let ((*current-segment* :elsewhere))
        (label label)
;;         (unless (eq register :rdi)
;;           (inst :mov register :rdi))
        (inst :push register)
        (emit-call-1 'error-not-list nil)
;;         (emit-exit)
        (inst :exit)
        (setf (gethash key common-labels) label)))
    label))

(defun p2-endp (form target)
  (when (check-arg-count form 1)
    (let ((arg (%cadr form)))
      (process-1-arg arg :eax t)
      (let* ((LABEL1 (make-label))
             (LABEL2 (make-label))
             (common-labels (compiland-common-labels *current-compiland*))
             (ERROR (gethash :error-not-list common-labels)))
        (unless ERROR
          (setq ERROR (make-label))
          (let ((*current-segment* :elsewhere))
            (label ERROR)
            (p2-symbol 'LIST :stack)
            ;; arg is in eax
            (inst :push :eax)
            (emit-call-2 '%type-error nil)
            (inst :exit) ; FIXME
            (setf (gethash :error-not-list common-labels) ERROR)))
        (inst :compare-immediate nil :eax)
        (emit-jmp-short :e LABEL1)
        (inst :push :eax)
        (inst :and +lowtag-mask+ :al)
        (inst :cmp +list-lowtag+ :al)
        (inst :pop :eax)
        (emit-jmp-short :ne ERROR)
        (p2 nil :eax)
        (emit-jmp-short t LABEL2)
        (label LABEL1)
        (p2 t :eax)
        (label LABEL2)
        (clear-register-contents :eax)
        (when target
          (move-result-to-target target))
        t))))

(defknown p2-eq (t t) t)
(defun p2-eq (form target)
  (when (check-arg-count form 2)
    (let* ((EXIT (make-label)))
      (process-2-args (%cdr form) '(:eax :edx) t)
      (inst :cmp :edx :eax)
      (p2-symbol t :eax)
      (emit-jmp-short :e EXIT)
      (p2-symbol nil :eax)
      (label EXIT)
      (clear-register-contents :eax)
      (move-result-to-target target))
    t))

(defknown p2-neq (t t) t)
(defun p2-neq (form target)
  (when (check-arg-count form 2)
    (let* ((EXIT (make-label)))
      (process-2-args (%cdr form) '(:eax :edx) t)
      (inst :cmp :edx :eax)
      (p2-symbol t :eax)
      (emit-jmp-short :ne EXIT)
      (p2-symbol nil :eax)
      (label EXIT)
      (clear-register-contents :eax)
      (move-result-to-target target))
    t))

(defun p2-funcall (form target)
  (when (and (> (length form) 1)
             ;; If the operator names a special operator or macro, we need to
             ;; signal a program error (not a type error) in safe code.
             (< *safety* 3))
    (let* ((operator-form (%cadr form))
           (args (cddr form))
           (numargs (length args))
           (use-fast-call-p (use-fast-call-p))
           (thread-var (compiland-thread-var *current-compiland*))
           operator-derived-type)
      (cond ((and (consp operator-form)
                  (eq (%car operator-form) 'QUOTE)
                  (eql (length operator-form) 2)
                  (symbolp (%cadr operator-form)))
             (mumble "p2-funcall optimization 1~%")
             (p2-function-call (list* (%cadr operator-form) args) target)
             t)
            ((and (consp operator-form)
                  (eq (%car operator-form) 'FUNCTION)
                  (eql (length operator-form) 2)
                  (symbolp (%cadr operator-form)))
             (aver thread-var)
             (let* ((name (%cadr operator-form))
                    (kernel-function-p (kernel-function-p name)))
               (cond ((or kernel-function-p
                          (memq name *functions-defined-in-current-file*))
                      (case numargs
                        (1
                         (cond ((and use-fast-call-p
                                     kernel-function-p
                                     (eql (function-arity name) 1)
                                     (function-code-address (symbol-function name)))
                                (process-1-arg (%car args) :stack t)
                                (emit-call-1 name target))
                               (use-fast-call-p
                                (process-1-arg (%car args) :stack t)
                                (emit-move-function-to-register name :eax)
                                (inst :push :eax)
                                (emit-call-2 "RT_fast_call_function_1" target))
                               (t
                                (process-1-arg (%car args) :stack nil)
                                (emit-move-function-to-register name :eax)
                                (inst :push :eax)
                                (inst :push thread-var)
                                (emit-call-3 "RT_thread_call_function_1" target))))
                        (t
                         (mumble "p2-funcall optimization 2 needs work! numargs = ~D~%" numargs)
                         (p2-function-call (list* name args) target))))
                     (t
                      (p2-function-call (list* name args) target))))
             t)
            ((eq (setq operator-derived-type (derive-type operator-form)) 'SYMBOL)
             (mumble "p2-funcall optimization 3 numargs = ~D~%" numargs)
             (case numargs
               (1
                (cond (use-fast-call-p
                       (process-2-args (cdr form) :stack t)
                       (emit-call-2 "RT_fast_call_symbol_1" target)
                       t)
                      (thread-var
                       (process-2-args (cdr form) :stack nil)
                       (inst :push thread-var)
                       (emit-call-3 "RT_thread_call_symbol_1" target)
                       t)
                      (t
                       (mumble "p2-funcall not optimized 1a~%")
                       nil)))
               (4
                (cond (use-fast-call-p
                       (process-5-args (cdr form) :stack t)
                       (emit-call-5 "RT_fast_call_symbol_4" target)
                       t)
                      (thread-var
                       (process-5-args (cdr form) :stack nil)
                       (inst :push thread-var)
                       (emit-call-6 "RT_thread_call_symbol_4" target)
                       t)
                      (t
                       (mumble "p2-funcall not optimized 1b~%")
                       nil)))
               (t
                (mumble "p2-funcall not optimized 2~%")
                nil)))
            ((eq operator-derived-type 'FUNCTION)
             (when (<= 0 numargs 4)
                (cond (use-fast-call-p
                       (process-args (cdr form) :stack t)
                       (emit-call-n (format nil "RT_fast_call_function_~D" numargs)
                                    target (+ 1 numargs))
                       t)
                      (thread-var
                       (process-args (cdr form) :stack nil)
                       (inst :push thread-var)
                       (emit-call-n (format nil "RT_thread_call_function_~D" numargs)
                                    target (+ 2 numargs))
                       t)
                      (t
                       (mumble "p2-funcall not optimized 3b~%")
                       nil))))
            (t
             (when (<= 0 numargs 4)
               (cond (use-fast-call-p
                      (process-args (cdr form) :stack t)
                      (emit-call-n (format nil "RT_fast_funcall_~D" numargs)
                                   target (+ 1 numargs))
                      t)
                     (thread-var
                      (process-args (cdr form) :stack nil)
                      (inst :push thread-var)
                      (emit-call-n (format nil "RT_thread_funcall_~D" numargs)
                                   target (+ 2 numargs))
                      t)
                     (t
                      (mumble "p2-funcall not optimized 7~%")
                      nil)))))
      )))

(defun p2-list3 (form target)
  (when (check-arg-count form 3)
    (process-3-args (%cdr form) :stack t)
    (emit-call-3 'list3 target)
    t))

(defun p2-list4 (form target)
  (when (check-arg-count form 4)
    (process-4-args (%cdr form) :stack t)
    (emit-call-4 'list4 target)
    t))

(defun p2-not/null (form target)
  (when (check-arg-count form 1)
    (let ((arg (%cadr form)))
      (cond ((and (consp arg)
                  (memq (%car arg) '(NOT NULL)))
             (p2 (cadr arg) :eax)
             (unless (single-valued-p (cadr arg))
               (emit-clear-values :preserve :eax))
             (p2-symbol nil :edx)
             (clear-register-contents :eax :edx)
             (inst :cmp :edx :eax)
             (cond ((eq target :return)
                    (let ((LABEL1 (make-label)))
                      (emit-jmp-short :ne LABEL1)
                      (p2-symbol nil :eax)
                      (inst :exit)
                      (label LABEL1)
                      (p2-symbol t :eax)
                      (inst :exit)))
                   (t
                    (let ((LABEL1 (make-label))
                          (LABEL2 (make-label)))
                      (emit-jmp-short :ne LABEL1)
                      (p2-symbol nil :eax)
                      (emit-jmp-short t LABEL2)
                      (label LABEL1)
                      (p2-symbol t :eax)
                      (label LABEL2)
                      (move-result-to-target target)))))
            (t
             (let ((NO (gensym))
                   (EXIT (gensym)))
               (p2 arg :eax)
               (unless (single-valued-p arg)
                 (emit-clear-values :preserve :eax))
               (inst :compare-immediate nil :eax)
               (emit-jmp-short :ne NO)
               (p2-symbol t :eax)
               (emit-jmp-short t EXIT)
               (label NO)
               (p2-symbol nil :eax)
               (label EXIT)
               (clear-register-contents :eax)
               (move-result-to-target target)))))
    t))

(defun p2-require-type (form target)
  (when (check-arg-count form 2)
    (let* ((args (%cdr form))
           (arg1 (%car args))
           (arg2 (%cadr args))
           type1)
      (cond ((zerop *safety*)
             (p2 arg1 target))
            ((and (quoted-form-p arg2)
                  (neq (setq type1 (derive-type arg1)) :unknown)
                  (subtypep type1 (%cadr arg2)))
             (p2 arg1 target))
            (t
             (process-2-args args :stack t)
             (p2-symbol 'require-type :stack)
             (emit-call-3 "RT_fast_call_symbol_2" target))))
    t))

(defun p2-require-fixnum (form target)
  (when (check-arg-count form 1)
    (let ((arg (%cadr form)))
      (cond ((zerop *safety*)
             (p2 arg target))
            ((fixnum-type-p (derive-type arg))
             (p2 arg target))
            (t
             (process-1-arg arg :eax t)
             (let* ((common-labels (compiland-common-labels *current-compiland*))
                    (ERROR (gethash :require-fixnum-error common-labels)))
               (unless ERROR
                 (setq ERROR (make-label))
                 (let ((*current-segment* :elsewhere)
                       (*register-contents* (copy-register-contents)))
                   (label ERROR)
                   (p2-symbol 'FIXNUM :stack)
                   (inst :push :eax)
                   (emit-call-2 '%type-error nil)
                   (inst :exit) ; FIXME
                   (setf (gethash :require-fixnum-error common-labels) ERROR)))
               (inst :test +fixnum-tag-mask+ :al)
               (emit-jmp-short :nz ERROR)
               (move-result-to-target target)
               (when (var-ref-p arg)
                 (add-type-constraint (var-ref-var arg) 'FIXNUM))))))
    t))

(defun p2-check-fixnum-bounds (form target)
  (when (check-arg-count form 3)
    (let* ((args (%cdr form))
           (arg1 (%car args))
           (arg2 (%cadr args))
           (arg3 (%caddr args))
           (derived-type (derive-type arg1)))
      (cond ((zerop *safety*)
             (p2 arg1 target))
            ((and (fixnump arg2)
                  (fixnump arg3)
                  (neq derived-type :unknown)
                  (subtypep derived-type (list 'INTEGER arg2 arg3)))
             (p2 arg1 target))
            ((and (fixnump arg2)
                  (fixnump arg3)
                  (typep (fixnumize arg2) '(signed-byte 32))
                  (typep (fixnumize arg3) '(signed-byte 32)))
             (let ((FAIL (make-label)))
               (process-1-arg arg1 :eax t)
               (inst :test +fixnum-tag-mask+ :al)
               (emit-jmp-short :nz FAIL)
               (inst :cmp (fixnumize arg2) :eax)
               (emit-jmp-short :l FAIL)
               (inst :cmp (fixnumize arg3) :eax)
               (emit-jmp-short :g FAIL)
               (when target
                 (move-result-to-target target))
               (let ((*current-segment* :elsewhere)
                     (*register-contents* nil))
                 (label FAIL)
                 (inst :push :eax)
                 (inst :push (fixnumize arg3))
                 (inst :push (fixnumize arg2))
                 (p2-symbol 'INTEGER :stack)
                 (emit-call-3 'LIST3 :eax)
                 (inst :pop :edx)
                 (inst :push :eax)
                 (inst :push :edx)
                 (emit-call-2 '%type-error nil)
                 (inst :exit) ; FIXME
                 )))
            (t
             (mumble "p2-check-fixnum-bounds full call~%")
             (process-3-args args :default t)
             (emit-call-3 'check-fixnum-bounds target))))
    t))

(defun p2-require-vector (form target)
  (let ((op (%car form))
        (arg (%cadr form))
        type)
    (aver (eq op 'require-vector))
    (cond ((zerop *safety*)
           (p2 arg target))
          ((and (neq (setq type (derive-type arg)) :unknown)
                (subtypep type 'VECTOR))
           (p2 arg target))
          (t
           (mumble "p2-require-vector~%")
           (let ((FAIL (gensym)))
             (process-1-arg arg :eax t)
             (inst :mov :eax :edx)
             (clear-register-contents :eax :edx)
             (inst :and +lowtag-mask+ :al)
             (inst :cmp +typed-object-lowtag+ :al)
             (emit-jmp-short :ne FAIL)
             (inst :mov :edx :eax)
             (inst :mov `(,(- +widetag-offset+ +typed-object-lowtag+) :eax) :eax) ; widetag in rax
             (aver (typep +widetag-vector-bit+ '(signed-byte 32)))
             (inst :and +widetag-vector-bit+ :eax)
             (emit-jmp-short :z FAIL)
             (when target
               (inst :mov :edx :eax)
               (move-result-to-target target))
             (let ((*current-segment* :elsewhere))
               (label FAIL)
               (p2-symbol 'VECTOR :stack)
               (inst :push :edx)
               (emit-call-2 '%type-error nil)
               (inst :exit) ; FIXME
               )))))
  t)

(defun p2-require-simple-string (form target)
  (let ((op (%car form))
        (arg (%cadr form))
        type)
    (aver (eq op 'require-simple-string))
    (cond ((zerop *safety*)
           (p2 arg target))
          ((and (neq (setq type (derive-type arg)) :unknown)
                (subtypep type 'SIMPLE-STRING))
           (p2 arg target))
          (t
           (mumble "p2-require-simple-string~%")
           (let* ((common-labels (compiland-common-labels *current-compiland*))
                  (REQUIRE-SIMPLE-STRING-ERROR (gethash :require-simple-string-error common-labels)))
             (when REQUIRE-SIMPLE-STRING-ERROR
               (mumble "p2-require-simple-string re-using label~%"))
             (unless REQUIRE-SIMPLE-STRING-ERROR
               (setq REQUIRE-SIMPLE-STRING-ERROR (make-label))
               (let ((*current-segment* :elsewhere))
                 (label REQUIRE-SIMPLE-STRING-ERROR)
                 (p2-symbol 'SIMPLE-STRING :stack)
                 (inst :push :edx)
                 (emit-call-2 '%type-error nil)
                 ;; FIXME
                 (inst :exit))
               (setf (gethash :require-simple-string-error common-labels) REQUIRE-SIMPLE-STRING-ERROR))
             (process-1-arg arg :eax t)
             (inst :mov :eax :edx)
             (inst :and +lowtag-mask+ :al)
             (clear-register-contents :eax :edx)
             (inst :cmp +typed-object-lowtag+ :al)
             (emit-jmp-short :ne REQUIRE-SIMPLE-STRING-ERROR)
             (inst :mov :edx :eax)
             (inst :sub +typed-object-lowtag+ :eax)
             (inst :mov `(,+bytes-per-word+ :eax) :eax) ; widetag in eax
             (aver (typep +simple-string-widetag+ '(signed-byte 32)))
             (inst :cmp +simple-string-widetag+ :eax)
             (emit-jmp-short :ne REQUIRE-SIMPLE-STRING-ERROR)
             (when target
               (inst :mov :edx :eax)
               (move-result-to-target target))
             (when (var-ref-p arg)
               (mumble "p2-require-simple-string adding type constraint for ~S~%"
                       (var-name (var-ref-var arg)))
               (add-type-constraint (var-ref-var arg) 'SIMPLE-STRING))))))
  t)

(defun p2-require-simple-vector (form target)
  (let ((op (%car form))
        (arg (%cadr form))
        type)
    (aver (eq op 'require-simple-vector))
    (cond ((zerop *safety*)
           (p2 arg target))
          ((and (neq (setq type (derive-type arg)) :unknown)
                (subtypep type 'SIMPLE-VECTOR))
           (p2 arg target))
          (t
           (mumble "p2-require-simple-vector~%")
           (let* ((common-labels (compiland-common-labels *current-compiland*))
                  (REQUIRE-SIMPLE-VECTOR-ERROR (gethash :require-simple-vector-error common-labels)))
             (when REQUIRE-SIMPLE-VECTOR-ERROR
               (mumble "p2-require-simple-vector re-using label~%"))
             (unless REQUIRE-SIMPLE-VECTOR-ERROR
               (setq REQUIRE-SIMPLE-VECTOR-ERROR (make-label))
               (let ((*current-segment* :elsewhere))
                 (label REQUIRE-SIMPLE-VECTOR-ERROR)
                 (p2-symbol 'SIMPLE-VECTOR :stack)
                 (inst :push :edx)
                 (emit-call-2 '%type-error nil)
                 ;; FIXME
                 (inst :exit))
               (setf (gethash :require-simple-vector-error common-labels) REQUIRE-SIMPLE-VECTOR-ERROR))
             (process-1-arg arg :eax t)
             (inst :mov :eax :edx)
             (inst :and +lowtag-mask+ :al)
             (clear-register-contents :eax :edx)
             (inst :cmp +typed-object-lowtag+ :al)
             (emit-jmp-short :ne REQUIRE-SIMPLE-VECTOR-ERROR)
             (inst :mov :edx :eax)
             (inst :sub +typed-object-lowtag+ :eax)
             (inst :mov `(,+bytes-per-word+ :eax) :eax) ; widetag in eax
             (aver (typep +simple-vector-widetag+ '(signed-byte 32)))
             (inst :cmp +simple-vector-widetag+ :eax)
             (emit-jmp-short :ne REQUIRE-SIMPLE-VECTOR-ERROR)
             (when target
               (inst :mov :edx :eax)
               (move-result-to-target target))
             (when (var-ref-p arg)
               (mumble "p2-require-simple-vector adding type constraint for ~S~%"
                       (var-name (var-ref-var arg)))
               (add-type-constraint (var-ref-var arg) 'SIMPLE-VECTOR))))))
  t)

(defun p2-%type-error (form target)
  (when (check-arg-count form 2)
    (process-2-args (%cdr form) :stack t)
    (emit-call-2 '%type-error target)
    t))

(defun p2-structure-ref (form target)
  (when (check-arg-count form 2)
    (let* ((args (%cdr form))
           (arg1 (%car args))
           (arg2 (%cadr args))
           type1)
      (cond ((and (fixnump arg2)
                  (or (zerop *safety*)
                      (and (neq (setq type1 (derive-type arg1)) :unknown)
                           (subtypep type1 'structure-object))))
             (process-1-arg arg1 :eax t)
             (clear-register-contents :eax)
             (let ((displacement (+ (- +typed-object-lowtag+)
                                    +structure-slots-offset+
                                    (* arg2 +bytes-per-word+))))
               (inst :mov `(,displacement :eax) :eax))
             (move-result-to-target target)
             t)
            (t
             nil)))))

(defun p2-structure-set (form target)
  (when (check-arg-count form 3)
    (let* ((args (%cdr form))
           (arg1 (%car args))
           (arg2 (%cadr args))
           (arg3 (%caddr args))
           type1)
      (cond ((and (fixnump arg2)
                  (or (zerop *safety*)
                      (and (neq (setq type1 (derive-type arg1)) :unknown)
                           (subtypep type1 'structure-object))))
             (cond ((and (constant-or-local-var-ref-p arg1) (constant-or-local-var-ref-p arg3))
                    (process-1-arg arg1 :edx t)
                    (process-1-arg arg3 :eax t))
                   (t
                    (process-1-arg arg1 :stack t)
                    (process-1-arg arg3 :eax t)
                    (inst :pop :edx)))
             (clear-register-contents :edx)
             (let ((displacement (+ (- +typed-object-lowtag+)
                                    +structure-slots-offset+
                                    (* arg2 +bytes-per-word+))))
               (inst :mov :eax `(,displacement :edx)))
             (move-result-to-target target)
             t)
            (t
             nil)))))

(defun p2-values (form target)
  (let* ((args (cdr form))
         (numargs (length args))
         (thread-var (compiland-thread-var *current-compiland*)))
;;     (declare (type var thread-var))
    (case numargs
      (0
       (inst :mov thread-var :eax)
       (clear-register-contents :eax)
       (inst :movb 0 `(,+values-length-offset+ :eax))
       (p2-symbol nil :eax)
       (move-result-to-target target)
       t)
      (1
       (process-1-arg (%car args) :eax t)
       (move-result-to-target target)
       t)
      (2
       (process-2-args args '(:eax :edx) nil)
       (inst :mov thread-var :ecx)
       (clear-register-contents :ecx)
       (inst :mov :eax `(,+values-offset+ :ecx))
       (inst :mov :edx `(,(+ +values-offset+ +bytes-per-word+) :ecx))
       (inst :movb 2 `(,+values-length-offset+ :ecx))
       (move-result-to-target target)
       t)
      (3
       (process-3-args args :stack nil)
       (inst :mov thread-var :ecx)
       (clear-register-contents :ecx)
       (inst :pop :eax)
       (clear-register-contents :eax)
       (inst :mov :eax `(,+values-offset+ :ecx))
       (inst :pop `(,(+ +values-offset+ +bytes-per-word+) :ecx))
       (inst :pop `(,(+ +values-offset+ (* 2 +bytes-per-word+)) :ecx))
       (inst :movb 3 `(,+values-length-offset+ :ecx))
       (move-result-to-target target)
       t)
      (4
       (process-4-args args :stack nil)
       (inst :mov thread-var :ecx)
       (clear-register-contents :ecx)
       (inst :pop :eax)
       (clear-register-contents :eax)
       (inst :mov :eax `(,+values-offset+ :ecx))
       (inst :pop `(,(+ +values-offset+ +bytes-per-word+) :ecx))
       (inst :pop `(,(+ +values-offset+ (* 2 +bytes-per-word+)) :ecx))
       (inst :pop `(,(+ +values-offset+ (* 3 +bytes-per-word+)) :ecx))
       (inst :movb 4 `(,+values-length-offset+ :ecx))
       (move-result-to-target target)
       t))))
