;;; setf.lisp
;;;
;;; Copyright (C) 2003-2009 Peter Graves <peter@armedbear.org>
;;;
;;; This program is free software; you can redistribute it and/or
;;; modify it under the terms of the GNU General Public License
;;; as published by the Free Software Foundation; either version 2
;;; of the License, or (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

(in-package "SYSTEM")

(export 'assign-setf-inverse)

(defun get-setf-method-inverse (form inverse setf-function)
  (let ((new-var (gensym))
        (vars nil)
        (vals nil))
    (dolist (x (cdr form))
      (push (gensym) vars)
      (push x vals))
    (setq vals (nreverse vals))
    (values vars vals (list new-var)
            (if setf-function
                `(,@inverse ,new-var ,@vars)
                (if (functionp (car inverse))
                    `(funcall ,@inverse ,@vars ,new-var)
                    `(,@inverse ,@vars ,new-var)))
            `(,(car form) ,@vars))))

;;; If a macro, expand one level and try again.  If not, go for the
;;; SETF function.
(defun expand-or-get-setf-inverse (form environment)
  (multiple-value-bind (expansion expanded)
      (macroexpand-1 form environment)
    (if expanded
        (get-setf-expansion expansion environment)
        (get-setf-method-inverse form `(funcall #'(setf ,(car form)))
                                 t))))

(defun get-setf-expansion (form &optional environment)
  (when (and (consp form) (autoloadp (%car form)))
    (resolve (%car form)))
  (let (temp)
    (cond ((symbolp form)
           (let ((new-var (gensym)))
             (values nil nil (list new-var)
                     `(setq ,form ,new-var) form)))
          ((setq temp (get (car form) 'setf-inverse))
           (get-setf-method-inverse form `(,temp) nil))
          ((setq temp (get (car form) 'setf-expander))
           (funcall temp form environment))
          (t
           (expand-or-get-setf-inverse form environment)))))

(defmacro setf (&rest args &environment environment)
  (let ((numargs (length args)))
    (cond ((eql numargs 2)
           (let ((place (%car args))
                 (value-form (%cadr args)))
             (if (atom place)
                 `(setq ,place ,value-form)
                 (progn
                   (when (symbolp (%car place))
                     (resolve (%car place)))
                   (multiple-value-bind (dummies vals store-vars setter getter)
                       (get-setf-expansion place environment)
                     (declare (ignore getter)) ; REVIEW
                     (let ((inverse (get (%car place) 'setf-inverse)))
                       (if (and inverse (eq inverse (car setter)))
                           (if (functionp inverse)
                               `(funcall ,inverse ,@(%cdr place) ,value-form)
                               `(,inverse ,@(%cdr place) ,value-form))
                           (if (or (null store-vars) (cdr store-vars))
                               `(let* (,@(mapcar #'list dummies vals))
                                  (multiple-value-bind ,store-vars ,value-form
                                    ,setter))
                               `(let* (,@(mapcar #'list dummies vals)
                                       ,(list (%car store-vars) value-form))
                                  ,setter)))))))))
          ((oddp numargs)
           (error "Odd number of arguments to SETF."))
          (t
           (do ((a args (cddr a))
                (l nil))
               ((null a) `(progn ,@(nreverse l)))
             (setq l (cons (list 'setf (car a) (cadr a)) l)))))))

;; Adapted from SBCL.
(defmacro push (item place)
  (if (and (symbolp place)
	   (eq place (macroexpand place)))
      `(setq ,place (cons ,item ,place))
      (multiple-value-bind (dummies vals newval setter getter)
          (get-setf-expansion place)
        (let ((g (gensym)))
          `(let* ((,g ,item)
                  ,@(mapcar #'list dummies vals)
                  (,(car newval) (cons ,g ,getter)))
             ,setter)))))

;; Adapted from SBCL.
(defmacro pop (place &environment environment)
  (if (and (symbolp place)
	   (eq place (macroexpand place)))
      `(prog1
         (car ,place)
         (setq ,place (cdr ,place)))
      (multiple-value-bind (dummies vals newval setter getter)
          (get-setf-expansion place environment)
        (do* ((d dummies (cdr d))
              (v vals (cdr v))
              (let-list nil))
             ((null d)
              (push (list (car newval) getter) let-list)
              `(let* ,(nreverse let-list)
                 (prog1
                   (car ,(car newval))
                   (setq ,(car newval) (cdr ,(car newval)))
                   ,setter)))
          (push (list (car d) (car v)) let-list)))))

(defun set-subseq (sequence start &rest rest)
  (let ((end nil) v)
    (ecase (length rest)
      (1
       (setq v (%car rest)))
      (2
       (setq end (%car rest)
             v (%cadr rest))))
    (progn
      (replace sequence v :start1 start :end1 end)
      v)))

(defun assign-setf-inverse (access-function update-function)
  (put access-function 'setf-inverse update-function))

(assign-setf-inverse 'aref 'aset)
(assign-setf-inverse 'bit 'aset)
(assign-setf-inverse 'char 'set-char)
(assign-setf-inverse 'elt 'setelt)
(assign-setf-inverse 'fdefinition 'set-fdefinition)
(assign-setf-inverse 'fill-pointer 'set-fill-pointer)
(assign-setf-inverse 'get 'put)
(assign-setf-inverse 'get2 'put)
(assign-setf-inverse 'get3 'put)
(assign-setf-inverse 'gethash 'puthash)
(assign-setf-inverse 'gethash2 'puthash)
(assign-setf-inverse 'iref 'iset)
(assign-setf-inverse 'macro-function 'set-macro-function)
(assign-setf-inverse 'nth 'set-nth)
(assign-setf-inverse 'readtable-case 'set-readtable-case)
(assign-setf-inverse 'row-major-aref 'row-major-aset)
(assign-setf-inverse 'sbit 'set-sbit)
(assign-setf-inverse 'sbit1 'set-sbit1)
(assign-setf-inverse 'schar 'set-schar)
(assign-setf-inverse 'subseq 'set-subseq)
(assign-setf-inverse 'subseq2 'set-subseq)
(assign-setf-inverse 'subseq3 'set-subseq)
(assign-setf-inverse 'svref 'svset)
(assign-setf-inverse 'symbol-function 'set-symbol-function)
(assign-setf-inverse 'symbol-global-value 'set-symbol-global-value)
(assign-setf-inverse 'symbol-plist 'set-symbol-plist)
(assign-setf-inverse 'symbol-value 'set)
(assign-setf-inverse 'vector-ref 'vector-set)

(defun set-caar   (x v) (setcar (car x)   v))
(defun set-cadr   (x v) (setcar (cdr x)   v))
(defun set-cdar   (x v) (setcdr (car x)   v))
(defun set-cddr   (x v) (setcdr (cdr x)   v))
(defun set-caaar  (x v) (setcar (caar x)  v))
(defun set-cadar  (x v) (setcar (cdar x)  v))
(defun set-cdaar  (x v) (setcdr (caar x)  v))
(defun set-cddar  (x v) (setcdr (cdar x)  v))
(defun set-caadr  (x v) (setcar (cadr x)  v))
(defun set-caddr  (x v) (setcar (cddr x)  v))
(defun set-cdadr  (x v) (setcdr (cadr x)  v))
(defun set-cdddr  (x v) (setcdr (cddr x)  v))
(defun set-caaaar (x v) (setcar (caaar x) v))
(defun set-cadaar (x v) (setcar (cdaar x) v))
(defun set-cdaaar (x v) (setcdr (caaar x) v))
(defun set-cddaar (x v) (setcdr (cdaar x) v))
(defun set-caadar (x v) (setcar (cadar x) v))
(defun set-caddar (x v) (setcar (cddar x) v))
(defun set-cdadar (x v) (setcdr (cadar x) v))
(defun set-cdddar (x v) (setcdr (cddar x) v))
(defun set-caaadr (x v) (setcar (caadr x) v))
(defun set-cadadr (x v) (setcar (cdadr x) v))
(defun set-cdaadr (x v) (setcdr (caadr x) v))
(defun set-cddadr (x v) (setcdr (cdadr x) v))
(defun set-caaddr (x v) (setcar (caddr x) v))
(defun set-cadddr (x v) (setcar (cdddr x) v))
(defun set-cdaddr (x v) (setcdr (caddr x) v))
(defun set-cddddr (x v) (setcdr (cdddr x) v))

(assign-setf-inverse 'car    'setcar)
(assign-setf-inverse 'cdr    'setcdr)
(assign-setf-inverse 'caar   'set-caar)
(assign-setf-inverse 'cadr   'set-cadr)
(assign-setf-inverse 'cdar   'set-cdar)
(assign-setf-inverse 'cddr   'set-cddr)
(assign-setf-inverse 'caaar  'set-caaar)
(assign-setf-inverse 'cadar  'set-cadar)
(assign-setf-inverse 'cdaar  'set-cdaar)
(assign-setf-inverse 'cddar  'set-cddar)
(assign-setf-inverse 'caadr  'set-caadr)
(assign-setf-inverse 'caddr  'set-caddr)
(assign-setf-inverse 'cdadr  'set-cdadr)
(assign-setf-inverse 'cdddr  'set-cdddr)
(assign-setf-inverse 'caaaar 'set-caaaar)
(assign-setf-inverse 'cadaar 'set-cadaar)
(assign-setf-inverse 'cdaaar 'set-cdaaar)
(assign-setf-inverse 'cddaar 'set-cddaar)
(assign-setf-inverse 'caadar 'set-caadar)
(assign-setf-inverse 'caddar 'set-caddar)
(assign-setf-inverse 'cdadar 'set-cdadar)
(assign-setf-inverse 'cdddar 'set-cdddar)
(assign-setf-inverse 'caaadr 'set-caaadr)
(assign-setf-inverse 'cadadr 'set-cadadr)
(assign-setf-inverse 'cdaadr 'set-cdaadr)
(assign-setf-inverse 'cddadr 'set-cddadr)
(assign-setf-inverse 'caaddr 'set-caaddr)
(assign-setf-inverse 'cadddr 'set-cadddr)
(assign-setf-inverse 'cdaddr 'set-cdaddr)
(assign-setf-inverse 'cddddr 'set-cddddr)

(assign-setf-inverse 'first 'setcar)
(assign-setf-inverse 'second 'set-cadr)
(assign-setf-inverse 'third 'set-caddr)
(assign-setf-inverse 'fourth 'set-cadddr)
(defun set-fifth (x v) (setcar (cddddr x) v))
(assign-setf-inverse 'fifth 'set-fifth)
(defun set-sixth (x v) (setcar (cdr (cddddr x)) v))
(assign-setf-inverse 'sixth 'set-sixth)
(defun set-seventh (x v) (setcar (cddr (cddddr x)) v))
(assign-setf-inverse 'seventh 'set-seventh)
(defun set-eighth (x v) (setcar (cdddr (cddddr x)) v))
(assign-setf-inverse 'eighth 'set-eighth)
(defun set-ninth (x v) (setcar (cddddr (cddddr x)) v))
(assign-setf-inverse 'ninth 'set-ninth)
(defun set-tenth (x v) (setcar (cdr (cddddr (cddddr x))) v))
(assign-setf-inverse 'tenth 'set-tenth)

(assign-setf-inverse 'rest 'setcdr)

(defun (setf find-class) (new-class symbol &optional errorp environment)
  (declare (ignore errorp environment))
  (set-find-class symbol new-class))
