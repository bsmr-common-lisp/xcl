;;; subtypep.lisp
;;;
;;; Copyright (C) 2006-2009 Peter Graves <peter@armedbear.org>
;;;
;;; This program is free software; you can redistribute it and/or
;;; modify it under the terms of the GNU General Public License
;;; as published by the Free Software Foundation; either version 2
;;; of the License, or (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

(in-package "SYSTEM")

(defparameter *known-types* (make-hash-table :test 'eq))

(defun initialize-known-types ()
  (let ((ht (make-hash-table :test 'eq)))
    (dolist (i '((ARITHMETIC-ERROR ERROR SERIOUS-CONDITION CONDITION)
                 (ARRAY)
                 (ATOM)
                 (BASE-CHAR CHARACTER)
                 (BASE-STRING STRING VECTOR ARRAY SEQUENCE)
                 (BIGNUM INTEGER SIGNED-BYTE RATIONAL REAL NUMBER)
                 (BIT FIXNUM UNSIGNED-BYTE INTEGER SIGNED-BYTE RATIONAL REAL NUMBER)
                 (BIT-VECTOR VECTOR ARRAY SEQUENCE)
                 (BOOLEAN SYMBOL)
                 (BUILT-IN-CLASS CLASS STANDARD-OBJECT)
                 (CELL-ERROR ERROR SERIOUS-CONDITION CONDITION)
                 (CHARACTER BASE-CHAR)
                 (CLASS STANDARD-OBJECT)
                 (COMPILED-FUNCTION FUNCTION)
                 (COMPLEX NUMBER)
                 (CONDITION)
                 (CONS LIST SEQUENCE)
                 (CONTROL-ERROR ERROR SERIOUS-CONDITION CONDITION)
                 (DIVISION-BY-ZERO ARITHMETIC-ERROR ERROR  SERIOUS-CONDITION CONDITION)
                 (DOUBLE-FLOAT LONG-FLOAT FLOAT REAL NUMBER)
                 (END-OF-FILE STREAM-ERROR ERROR SERIOUS-CONDITION CONDITION)
                 (ERROR SERIOUS-CONDITION CONDITION)
                 (EXTENDED-CHAR NIL CHARACTER)
                 (FILE-ERROR ERROR SERIOUS-CONDITION CONDITION)
                 (FIXNUM INTEGER SIGNED-BYTE RATIONAL REAL NUMBER)
                 (FLOAT REAL NUMBER)
                 (FLOATING-POINT-INEXACT ARITHMETIC-ERROR ERROR SERIOUS-CONDITION CONDITION)
                 (FLOATING-POINT-INVALID-OPERATION ARITHMETIC-ERROR ERROR SERIOUS-CONDITION CONDITION)
                 (FLOATING-POINT-OVERFLOW ARITHMETIC-ERROR ERROR SERIOUS-CONDITION CONDITION)
                 (FLOATING-POINT-UNDERFLOW ARITHMETIC-ERROR ERROR SERIOUS-CONDITION CONDITION)
                 (FUNCTION)
                 (GENERIC-FUNCTION FUNCTION)
                 (HASH-TABLE)
                 (INTEGER SIGNED-BYTE RATIONAL REAL NUMBER)
                 (KEYWORD SYMBOL)
                 (LIST SEQUENCE)
                 (LONG-FLOAT DOUBLE-FLOAT FLOAT REAL NUMBER)
                 (NIL-VECTOR SIMPLE-STRING STRING VECTOR SIMPLE-ARRAY ARRAY SEQUENCE)
                 (NULL BOOLEAN SYMBOL LIST SEQUENCE)
                 (NUMBER)
                 (PACKAGE)
                 (PACKAGE-ERROR ERROR SERIOUS-CONDITION CONDITION)
                 (PARSE-ERROR ERROR SERIOUS-CONDITION CONDITION)
                 (PATHNAME)
                 (PRINT-NOT-READABLE ERROR SERIOUS-CONDITION CONDITION)
                 (PROGRAM-ERROR ERROR SERIOUS-CONDITION CONDITION)
                 (RANDOM-STATE)
                 (RATIO RATIONAL REAL NUMBER)
                 (RATIONAL REAL NUMBER)
                 (READER-ERROR PARSE-ERROR STREAM-ERROR ERROR SERIOUS-CONDITION CONDITION)
                 (READTABLE)
                 (REAL NUMBER)
                 (RESTART)
                 (SERIOUS-CONDITION CONDITION)
                 (SHORT-FLOAT SINGLE-FLOAT FLOAT REAL NUMBER)
                 (SIMPLE-ARRAY ARRAY)
                 (SIMPLE-BASE-STRING BASE-STRING SIMPLE-STRING STRING VECTOR SIMPLE-ARRAY ARRAY SEQUENCE)
                 (SIMPLE-BIT-VECTOR BIT-VECTOR VECTOR SIMPLE-ARRAY ARRAY SEQUENCE)
                 (SIMPLE-CONDITION CONDITION)
                 (SIMPLE-ERROR SIMPLE-CONDITION ERROR SERIOUS-CONDITION CONDITION)
                 (SIMPLE-STRING STRING VECTOR SIMPLE-ARRAY ARRAY SEQUENCE)
                 (SIMPLE-TYPE-ERROR SIMPLE-CONDITION TYPE-ERROR ERROR SERIOUS-CONDITION CONDITION)
                 (SIMPLE-VECTOR VECTOR SIMPLE-ARRAY ARRAY SEQUENCE)
                 (SIMPLE-WARNING SIMPLE-CONDITION WARNING CONDITION)
                 (SIGNED-BYTE INTEGER RATIONAL REAL NUMBER)
                 (SINGLE-FLOAT SHORT-FLOAT FLOAT REAL NUMBER)
                 (STANDARD-CHAR BASE-CHAR CHARACTER)
                 (STANDARD-CLASS CLASS STANDARD-OBJECT)
                 (STANDARD-GENERIC-FUNCTION GENERIC-FUNCTION FUNCTION)
                 (STANDARD-OBJECT)
                 (STORAGE-CONDITION SERIOUS-CONDITION CONDITION)
                 (STREAM)
                 (STREAM-ERROR ERROR SERIOUS-CONDITION CONDITION)
                 (STRING VECTOR ARRAY SEQUENCE)
                 (STRUCTURE-CLASS CLASS STANDARD-OBJECT)
                 (STYLE-WARNING WARNING CONDITION)
                 (SYMBOL)
                 (TWO-WAY-STREAM STREAM)
                 (TYPE-ERROR ERROR SERIOUS-CONDITION CONDITION)
                 (UNBOUND-SLOT CELL-ERROR ERROR SERIOUS-CONDITION CONDITION)
                 (UNBOUND-VARIABLE CELL-ERROR ERROR SERIOUS-CONDITION CONDITION)
                 (UNDEFINED-FUNCTION CELL-ERROR ERROR SERIOUS-CONDITION CONDITION)
                 (VECTOR ARRAY SEQUENCE)
                 (WARNING CONDITION)))
      (setf (gethash (%car i) ht) (%cdr i)))
    (setf *known-types* ht)))

(initialize-known-types)

(defun known-type-p (type)
  (multiple-value-bind (value present-p)
      (gethash2 type *known-types*)
    (declare (ignore value))
    present-p))

(defun simple-subtypep (type1 type2)
  (if (memq type2 (gethash2 type1 *known-types*))
      t
      nil))

(defun sub-interval-p (i1 i2)
  (let (low1 high1 low2 high2)
    (if (null i1)
        (setq low1 '* high1 '*)
        (if (null (cdr i1))
            (setq low1 (%car i1) high1 '*)
            (setq low1 (%car i1) high1 (cadr i1))))
    (if (null i2)
        (setq low2 '* high2 '*)
        (if (null (cdr i2))
            (setq low2 (%car i2) high2 '*)
            (setq low2 (%car i2) high2 (cadr i2))))
    (when (and (consp low1) (integerp (%car low1)))
      (setq low1 (1+ (%car low1))))
    (when (and (consp low2) (integerp (%car low2)))
      (setq low2 (1+ (%car low2))))
    (when (and (consp high1) (integerp (%car high1)))
      (setq high1 (1- (%car high1))))
    (when (and (consp high2) (integerp (%car high2)))
      (setq high2 (1- (%car high2))))
    (cond ((eq low1 '*)
	   (unless (eq low2 '*)
             (return-from sub-interval-p nil)))
          ((eq low2 '*))
	  ((consp low1)
	   (if (consp low2)
	       (when (< (%car low1) (%car low2))
                 (return-from sub-interval-p nil))
	       (when (< (%car low1) low2)
                 (return-from sub-interval-p nil))))
	  ((if (consp low2)
	       (when (<= low1 (%car low2))
                 (return-from sub-interval-p nil))
	       (when (< low1 low2)
                 (return-from sub-interval-p nil)))))
    (cond ((eq high1 '*)
	   (unless (eq high2 '*)
             (return-from sub-interval-p nil)))
          ((eq high2 '*))
	  ((consp high1)
	   (if (consp high2)
	       (when (> (%car high1) (%car high2))
                 (return-from sub-interval-p nil))
	       (when (> (%car high1) high2)
                 (return-from sub-interval-p nil))))
	  ((if (consp high2)
	       (when (>= high1 (%car high2))
                 (return-from sub-interval-p nil))
	       (when (> high1 high2)
                 (return-from sub-interval-p nil)))))
    (return-from sub-interval-p t)))

(defconstant +array-types+
  '(ARRAY SIMPLE-ARRAY BIT-VECTOR SIMPLE-BIT-VECTOR VECTOR SIMPLE-VECTOR
    STRING SIMPLE-STRING BASE-STRING SIMPLE-BASE-STRING))

(defun dimension-subtypep (dim1 dim2)
  (cond ((eq dim2 '*)
         t)
        ((equal dim1 dim2)
         t)
        ((integerp dim2) ; rank
         (and (listp dim1) (eql (length dim1) dim2)))
        ((integerp dim1) ; rank
         (and (listp dim2)
              (eql (length dim2) dim1)
              (equal dim2 (make-list dim1 :initial-element '*))))
        ((and (listp dim1)
              (listp dim2)
              (eql (length dim1) (length dim2)))
         (do* ((list1 dim1 (%cdr list1))
               (list2 dim2 (%cdr list2))
               (e1 (%car list1) (car list1))
               (e2 (%car list2) (car list2)))
              ((null list1) t)
           (unless (or (eq e2 '*) (eql e1 e2))
             (return nil))))
        (t
         nil)))

(defun subtypep-array (t1 i1 t2 i2)
  (macrolet ((yes     () `(return-from subtypep-array (values t   t  )))
             (no      () `(return-from subtypep-array (values nil t  )))
             (unknown () `(return-from subtypep-array (values nil nil))))
    (cond ((and (classp t1) (eq (%class-name t1) 'array))
           (if (and (eq t2 'array) (equal i2 '(* *)))
               (yes)
               (no)))
          ((and (classp t2) (eq (%class-name t2) 'array))
           (yes))
          ((memq t2 (list 'sequence (find-class 'vector)))
           (let (;(e1 (car i1))
                 (d1 (cadr i1)))
             (cond ((or (integerp d1)
                        (and (consp d1) (eql (length d1) 1)))
                    (yes))
                   (t
                    (no)))))
          ((and (classp t2) (eq (%class-name t2) 'bit-vector))
           (let ((e1 (car i1))
                 (d1 (cadr i1)))
             (cond ((and (equal e1 '(integer 0 1))
                         (or (integerp d1)
                             (and (consp d1)
                                  (eql (length d1) 1))))
                    (yes))
                   (t
                    (no)))))
          ((and (classp t2) (eq (%class-name t2) 'nil-vector))
           (let ((e1 (car i1))
                 (d1 (cadr i1)))
             (cond ((and (null e1)
                         (or (integerp d1)
                             (and (consp d1)
                                  (eql (length d1) 1))))
                    (yes))
                   (t
                    (no)))))
          ((and (eq t1 'array) (neq t2 'array))
           (no))
          ((and (eq t2 'simple-array) (neq t1 'simple-array))
           (no))
          ((not (and (memq t1 '(array simple-array))
                     (memq t2 '(array simple-array))))
           (no))
          ((or (and (eq t1 'array) (eq t2 'array))
               (and (eq t1 'simple-array) (eq t2 'array))
               (and (eq t1 'simple-array) (eq t2 'simple-array)))
           (let ((e1 (car i1))
                 (e2 (car i2))
                 (d1 (cadr i1))
                 (d2 (cadr i2)))
             (cond ((and (eq e2 '*) (eq d2 '*))
                    (values t t))
                   ((and (eq e1 '*) (neq e2 '*))
                    (values nil t))
                   ((or (eq e2 '*)
                        (equal e1 e2)
                        (equal (upgraded-array-element-type e1)
                               (upgraded-array-element-type e2)))
                    (values (dimension-subtypep d1 d2) t))
                   (t
                    (values nil t)))))
          (t
           (aver (memq t1 '(array simple-array)))
;;            (aver (memq t2 '(array simple-array)))
           (unless (memq t2 '(array simple-array))
             (error "Unexpected type ~S." t2))
           (values nil t)))))

(defun %subtypep (type1 type2)
  (macrolet ((yes     () `(return-from %subtypep (values t   t  )))
             (no      () `(return-from %subtypep (values nil t  )))
             (unknown () `(return-from %subtypep (values nil nil))))
    (cond ((eq type1 type2)
           (yes))
          ((eq type2 t)
           (yes))
          ((eq type1 nil)
           (yes))
          ((eq type2 :unknown) ; REVIEW
           (unknown))
          ((eq type2 'ATOM)
           (if (memq type1 '(CONS LIST SEQUENCE)) (no) (yes))))
    (when (and (atom type1) (atom type2))
      (let* ((classp-1 (classp type1))
             (classp-2 (classp type2))
             class1 class2)
        (when (and (setq class1 (if classp-1
                                    type1
                                    (and (symbolp type1) (find-class type1 nil))))
                   (setq class2 (if classp-2
                                    type2
                                    (and (symbolp type2) (find-class type2 nil)))))
          (return-from %subtypep (values (subclassp class1 class2) t)))
        (when (or classp-1 classp-2)
          (let ((t1 (if classp-1 (%class-name type1) type1))
                (t2 (if classp-2 (%class-name type2) type2)))
            (if (simple-subtypep t1 t2)
                (yes)
                (when (and (known-type-p type1) (known-type-p type2))
                  (no)))))
        (if (simple-subtypep type1 type2)
            (yes)
            (when (and (known-type-p type1) (known-type-p type2))
              (no)))))
    (setq type1 (canonicalize-type type1)
          type2 (canonicalize-type type2))
    (when (eq type1 type2)
      (yes))
    (let (t1 t2 i1 i2)
      (if (atom type1)
          (setq t1 type1 i1 nil)
          (setq t1 (%car type1) i1 (%cdr type1)))
      (if (atom type2)
          (setq t2 type2 i2 nil)
          (setq t2 (%car type2) i2 (%cdr type2)))
      (cond ((null t1)
             (yes))
            ((or (eq t1 'not) (eq t2 'not))
             (unknown))
            ((and (eq t1 t2) (equal i1 i2))
             (unless (memq t1 '(eql member))
               (yes)))
            ((eq t1 'and)
             (dolist (tt i1)
               (let ((tv (%subtypep tt type2)))
                 (when tv (return-from %subtypep (values t t)))))
             (unknown))
            ((eq t2 'and)
             (dolist (tt i2)
               (multiple-value-bind (tv flag) (%subtypep type1 tt)
                 (unless tv (return-from %subtypep (values tv flag)))))
             (yes))
            ((eq t1 'or)
             (dolist (tt i1)
               (multiple-value-bind (tv flag) (%subtypep tt type2)
                 (unless tv (return-from %subtypep (values tv flag)))))
             (yes))
            ((eq t2 'or)
             (dolist (tt i2)
               (let ((tv (%subtypep type1 tt)))
                 (when tv (return-from %subtypep (values t t)))))
             (unknown))
            ((eq t1 'member)
             (dolist (element i1)
               (unless (typep element type2) (no)))
             (yes))
            ((eq t1 'eql)
             (case t2
               (EQL
                (return-from %subtypep (values (eql (car i1) (car i2)) t)))
               (SATISFIES
                (return-from %subtypep (values (funcall (car i2) (car i1)) t)))
               (t
                (return-from %subtypep (values (typep (car i1) type2) t)))))
            ((or (memq t1 +array-types+) (memq t2 +array-types+))
             (subtypep-array t1 i1 t2 i2))
;;             ((classp t2)
;;              (if (known-type-p (%class-name t2))
;;                  (%subtypep t1 t2)
;;                  (unknown)))
            ((classp t2)
             (let ((c1 (find-class t1 nil)))
               (if (and c1 (subclassp c1 t2))
                   (yes)
                   (unknown))))
            ((eq t1 'integer)
             (cond ((memq t2 '(integer rational real number))
                    (if (sub-interval-p i1 i2)
                        (yes)
                        (no)))
                   ((eq t2 'bignum)
                    (if (or (sub-interval-p i1 (list '* (list most-negative-fixnum)))
                            (sub-interval-p i1 (list (list most-positive-fixnum) '*)))
                        (yes)
                        (no)))
                   (t
                    (values nil (known-type-p t2)))))
            ((eq t1 'rational)
             (if (memq t2 '(rational real number))
                 (values (sub-interval-p i1 i2) t)
                 (values nil (known-type-p t2))))
            ((eq t1 'float)
             (if (memq t2 '(float real number))
                 (values (sub-interval-p i1 i2) t)
                 (values nil (known-type-p t2))))
            ((memq t1 '(single-float short-float))
             (if (memq t2 '(single-float short-float float real number))
                 (values (sub-interval-p i1 i2) t)
                 (values nil (known-type-p t2))))
            ((memq t1 '(double-float long-float))
             (if (memq t2 '(double-float long-float float real number))
                 (values (sub-interval-p i1 i2) t)
                 (values nil (known-type-p t2))))
            ((eq t1 'real)
             (if (memq t2 '(real number))
                 (values (sub-interval-p i1 i2) t)
                 (values nil (known-type-p t2))))
            ((eq t1 'complex)
             (if (eq t2 'complex)
                 (cond ((or (null i2) (eq i2 '*))
                        (yes))
                       ((eq i1 '*)
                        (no))
                       (t
                        (unless (cdr i1)
                          (setq i1 (car i1)))
                        (unless (cdr i2)
                          (setq i2 (car i2)))
                        (subtypep i1 i2)))
                 (no)))
            ((eq t1 'cons)
             (case t2
               ((LIST SEQUENCE)
                (yes))
               (CONS
                (when (and (%subtypep (car i1) (car i2))
                           (%subtypep (cadr i1) (cadr i2)))
                  (yes))))
             (return-from %subtypep (values nil (known-type-p t2))))
            (t
             (unknown))))))

(defun subtypep (type1 type2 &optional environment)
  (declare (ignore environment))
  (%subtypep type1 type2))
