;;; derive-type.lisp
;;;
;;; Copyright (C) 2006-2009 Peter Graves <peter@armedbear.org>
;;;
;;; This program is free software; you can redistribute it and/or
;;; modify it under the terms of the GNU General Public License
;;; as published by the Free Software Foundation; either version 2
;;; of the License, or (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

(in-package "COMPILER")

(defvar *constraints* nil)

(declaim (inline clear-constraints))
(defun clear-constraints ()
  (setq *constraints* nil))

(defstruct constraint
  var
  type
  )

(defknown add-type-constraint (var t) t)
(defun add-type-constraint (var type)
  (push (make-constraint :var var :type (canonicalize-type type)) *constraints*))

(defknown remove-constraints (var) t)
(defun remove-constraints (var)
  (when *constraints*
    (setq *constraints* (delete var *constraints* :key 'constraint-var))))

(defknown find-constraint (var) t)
(defun find-constraint (var)
  (dolist (constraint *constraints* nil)
    (when (eq (constraint-var constraint) var)
      (return constraint))))

(defknown constrained-type (t) t)
(defun constrained-type (var)
  (dolist (constraint *constraints*)
    (when (eq (constraint-var constraint) var)
      (return-from constrained-type (constraint-type constraint))))
  :unknown)

(defknown union-type-p (t) t)
(defun union-type-p (type)
  (and (consp type)
       (eq (%car type) 'OR)))

(defknown integer-type-p (cons) t)
(defun integer-type-p (type)
  (and (consp type)
       (eq (%car type) 'INTEGER)))

(defknown integer-type-low (cons) t)
(defun integer-type-low (type)
  (declare (type cons type))
  (aver (eq (%car type) 'INTEGER))
  (cadr type))

(defknown integer-type-high (cons) t)
(defun integer-type-high (type)
  (declare (type cons type))
  (aver (eq (%car type) 'INTEGER))
  (caddr type))

(defknown fixnum-type-p (t) t)
(defun fixnum-type-p (type)
  (and (integer-type-p type)
       (fixnump (integer-type-low  type))
       (fixnump (integer-type-high type))))

(defknown integer-constant-value (t) t)
(defun integer-constant-value (type)
  (when (and type (integer-type-p type))
    (let ((low (integer-type-low type))
          high)
      (when (integerp low)
        (setq high (integer-type-high type))
        (when (and (integerp high) (eql high low))
          high)))))

(defknown float-type-p (t) t)
(defun float-type-p (type)
  (if (atom type)
      (memq type '(SINGLE-FLOAT DOUBLE-FLOAT FLOAT))
      (subtypep type 'FLOAT)))

(defknown derive-type-var-ref (var-ref) t)
(defun derive-type-var-ref (form)
  (declare (type var-ref form))
  (let ((var (var-ref-var form)))
    (cond ((var-special-p var)
           (cond ((constantp (var-name var))
                  (canonicalize-type (type-of (symbol-global-value (var-name var)))))
                 (t
                  (let ((proclaimed-type (proclaimed-type (var-name var))))
                    (if (eq proclaimed-type :none)
                        :unknown
                        (canonicalize-type proclaimed-type))))))
          ((zerop *safety*)
           (let ((derived-type (var-derived-type var))
                 (declared-type (var-declared-type var)))
             (cond ((eq declared-type :none)
                    derived-type)
                   ((eq derived-type :unknown)
                    (canonicalize-type declared-type))
                   (t
                    (setq declared-type (canonicalize-type declared-type))
                    (if (subtypep declared-type derived-type)
                        declared-type
                        derived-type)))))
          (t
           (var-derived-type var)))))

(defknown derive-type (t) t)
(defun derive-type (form)
  (cond ((null form)
         'NULL)
        ((eq form t)
         'BOOLEAN)
        ((consp form)
         (let* ((op (%car form))
                (handler (and (symbolp op)
                              (get op 'derive-type-handler))))
           (cond (handler
                  (funcall handler form))
                 (t
                  (let ((result-type (function-result-type op)))
                    (when (eq result-type :unknown)
                      (let ((ftype (proclaimed-ftype op)))
                        (when ftype
                          (setq result-type (ftype-result-type ftype)))))
                    (cond ((eq result-type '*)
                           :unknown)
                          ((null result-type)
                           :unknown)
                          ((eq result-type :unknown)
                           :unknown)
                          ((and (consp result-type)
                                (eq (%car result-type) 'VALUES))
                           ;; REVIEW
                           ;; only consider the primary value
                           (if (length-eql result-type 1)
                               'NULL
                               (canonicalize-type (%cadr result-type))))
                          (t
                           (canonicalize-type result-type))))))))
        ((integerp form)
         (list 'INTEGER form form))
        ((characterp form)
         'CHARACTER)
        ((single-float-p form)
         'SINGLE-FLOAT)
        ((double-float-p form)
         'DOUBLE-FLOAT)
        ((simple-string-p form)
         'SIMPLE-STRING)
        ((stringp form)
         'STRING)
        ((var-ref-p form)
;;          (let ((derived-type (derive-type-var-ref form)))
;;            (cond ((neq derived-type :unknown)
;;                   derived-type)
;;                  (t
;;                   (constrained-type (var-ref-var form)))))
         (let ((derived-type (derive-type-var-ref form))
               (constrained-type (constrained-type (var-ref-var form))))
           (cond ((eq derived-type :unknown)
                  constrained-type)
                 ((eq constrained-type :unknown)
                  derived-type)
                 ((subtypep constrained-type derived-type)
                  constrained-type)
                 ((subtypep derived-type constrained-type)
                  derived-type)
                 ((union-type-p derived-type)
                  constrained-type)
                 (t
                  derived-type))))
        (t
         :unknown)))

(defun derive-type-aref (form)
  (when (>= (length form) 2)
    (let ((array-type (derive-type (%cadr form))))
      (when (and (consp array-type)
                 (memq (%car array-type) '(ARRAY SIMPLE-ARRAY)))
        (let ((element-type (cadr array-type)))
          (when (and element-type (neq element-type '*))
              (return-from derive-type-aref (canonicalize-type element-type)))))))
  :unknown)

(defun derive-type-make-array (form)
  (let* ((args (cdr form))
         (arg1 (car args))
         (type1 (derive-type arg1))
         (size '*)
         (element-type '*)
         result-type)
;;     (let ((*print-structure* nil))
;;       (format t "derive-type-make-array form = ~S~%" form))
;;     (format t "type1 = ~S~%" type1)
    (cond ((eq type1 :unknown))
          ((subtypep type1 'NUMBER)
           (setq size (list (or (integer-constant-value type1) '*)))))
;;     (format t "size = ~S~%" size)
    (let ((n (position :element-type args)))
      (cond (n
             (let ((arg (nth (1+ n) args)))
               (when (quoted-form-p arg)
                 (setq element-type (%cadr arg)))))
            (t
             ;; no element type specified
             (setq element-type t))))
;;     (format t "element-type = ~S~%" element-type)
    (setq result-type
          (list (if (intersection '(:adjustable :fill-pointer :displaced-to) args)
                    'ARRAY
                    'SIMPLE-ARRAY)
                element-type
                size))
    (setq result-type (canonicalize-type result-type))
;;     (format t "derive-type-make-array result-type = ~S~%" result-type)
    result-type
    ))

(defun derive-type-make-simple-vector (form)
  (let ((result-type 'SIMPLE-VECTOR))
    (when (length-eql form 2)
      (let ((arg (%cadr form))
            (size nil))
        (cond ((fixnump arg)
               (setq size arg))
              (t
               (let ((arg-type (derive-type arg)))
                 (setq size (and (neq arg-type :unknown)
                                 (integer-constant-value arg-type))))))
        (when (and size (>= size 0))
          (setq result-type (list 'SIMPLE-VECTOR size)))))
    (canonicalize-type result-type)))

(defknown derive-vector-size (t) (or null index))
(defun derive-vector-size (typespec)
  (when (consp typespec)
    (let ((name (%car typespec)))
      (when (and (eq name 'SIMPLE-ARRAY) (length-eql typespec 3))
        (let ((dimension-spec (%caddr typespec)))
          (when (consp dimension-spec)
            (let ((dimension (%car dimension-spec)))
              (when (and (fixnump dimension)
                         (>= dimension 0))
                dimension))))))))

(defknown derive-type-coerce (t) t)
(defun derive-type-coerce (form)
  (when (length-eql form 3)
    (let* ((arg2 (%caddr form)))
      (when (quoted-form-p arg2)
        (return-from derive-type-coerce (canonicalize-type (%cadr arg2))))))
  :unknown)

;; ash integer count => shifted-integer
(defknown derive-type-ash (t) t)
(defun derive-type-ash (form)
  (let* ((args (cdr form))
         (arg1 (car args))
         (arg2 (cadr args))
         (type1 (derive-type arg1))
;;          (type2 (derive-type arg2))
         type2
         (result-type '(INTEGER * *)))
    (when (and (integer-type-p type1)
               (integer-type-p (setq type2 (derive-type arg2))))
;;       (format t "derive-type-ash type1 = ~S type2 = ~S~%" type1 type2)
      (let ((low1  (integer-type-low  type1))
            (high1 (integer-type-high type1))
            (low2  (integer-type-low  type2))
            (high2 (integer-type-high type2)))
        (when (and (integerp low1)
                   (integerp high1)
                   (integerp low2)
                   (integerp high2))
          (cond ((fixnump arg2)
                 (cond ((<= -64 arg2 64)
                        (setq result-type
                              (list 'INTEGER (ash low1 arg2) (ash high1 arg2))))
                       ((minusp arg2)
                        (setf result-type
                              (list 'INTEGER
                                    (if (minusp low1)  -1 0)
                                    (if (minusp high1) -1 0))))))
                ((and (>= low1 0) (>= high1 0) (>= low2 0) (>= high2 0))
                 ;; everything is non-negative
                 (setq result-type (list 'INTEGER
                                         (ash low1 low2)
                                         (ash high1 high2))))
                ((and
;;                   (>= low1 0) (>= high1 0)
                  (<= low2 0) (<= high2 0))
                 ;; negative (or zero) second argument
                 (setq result-type (list 'INTEGER
                                         (ash low1 low2)
                                         (ash high1 high2))))))))
;;     (format t "derive-type-ash result-type = ~S~%" result-type)
    result-type))

(defun derive-type-logand (form)
;;   (format t "derive-type-logand called~%")
  (let ((args (cdr form)))
    (case (length args)
      (0
       '(INTEGER -1 -1))
      (1
       (let ((type (derive-type (%car args))))
         (if (integer-type-p type)
             type
             '(INTEGER * *))))
      (2
;;        (let ((*print-structure* nil))
;;          (format t "derive-type-logand arg1 = ~S~%" (%car args))
;;          (format t "derive-type-logand arg2 = ~S~%" (%cadr args)))
       (let ((result-type '(INTEGER * *))
             (type1 (derive-type (%car args))))
;;          (format t "type1 = ~S~%" type1)
         (when (neq type1 :unknown)
           (let ((type2 (derive-type (%cadr args))))
;;              (format t "type2 = ~S~%" type2)
             (when (neq type2 :unknown)
               (let ((low1  '*)
                     (high1 '*)
                     (low2  '*)
                     (high2 '*)
                     (result-low  '*)
                     (result-high '*))
                 (when (integer-type-p type1)
                   (setq low1  (integer-type-low  type1))
                   (setq high1 (integer-type-high type1)))
                 (when (integer-type-p type2)
                   (setq low2  (integer-type-low  type2))
                   (setq high2 (integer-type-high type2)))
                 (cond ((and (integerp low1)
                             (>= low1 0)
                             (integerp low2)
                             (>= low2 0))
                        ;; Both arguments are non-negative.
                        (setq result-low 0)
                        (setq result-high (if (and (integerp high1)
                                                   (integerp high2))
                                              (min high1 high2)
                                              (or  high1 high2))))
                       ((and (integerp low1)
                             (>= low1 0))
                        ;; arg1 is non-negative
                        (setq result-low  0)
                        (setq result-high high1))
                       ((and (integerp low2)
                             (>= low2 0))
                        ;; arg2 is non-negative
                        (setq result-low  0)
                        (setq result-high high2)))
                 (setq result-type (list 'INTEGER result-low result-high))))))
;;          (format t "derive-type-logand result-type = ~S~%" result-type)
         result-type))
      (t
       '(INTEGER * *)))))

(defknown derive-type-logior/logxor (t) t)
(defun derive-type-logior/logxor (form)
  (let ((op (car form))
        (args (cdr form))
        (result-type '(INTEGER * *)))
    (case (length args)
      (0
       (setq result-type '(INTEGER 0 0)))
      (1
       (setq result-type (derive-type (%car args))))
      (2
       (let ((type1 (derive-type (%car args)))
             (type2 (derive-type (%cadr args))))
         (cond ((or (eq type1 :unknown) (eq type2 :unknown)))
               ((and (subtypep type1 'UNSIGNED-BYTE)
                     (subtypep type2 'UNSIGNED-BYTE))
                (let ((high1 (integer-type-high type1))
                      (high2 (integer-type-high type2)))
                  (cond ((and (integerp high1)
                              (integerp high2))
                         (let ((length (integer-length (max high1 high2))))
                           (setq result-type (list 'INTEGER 0 (1- (expt 2 length))))))
                        (t
                         (setq result-type '(INTEGER 0 *))))))
               ((and (fixnum-type-p type1)
                     (fixnum-type-p type2))
                (setq result-type '(INTEGER #.most-negative-fixnum #.most-positive-fixnum))))))
      (t
       (setq result-type (derive-type-logior/logxor
                          `(,op ,(%car args) (,op ,@(%cdr args)))))))
    result-type))

(defknown derive-type-two-arg-+ (t) t)
(defun derive-type-two-arg-+ (form)
  (let ((args (cdr form))
        (result-type 'NUMBER))
    (when (length-eql args 2)
      (let ((type1 (derive-type (%car args))))
        (when (neq type1 :unknown)
          (let ((type2 (derive-type (%cadr args))))
            (when (neq type2 :unknown)
              (cond ((and (fixnum-type-p type1)
                          (fixnum-type-p type2))
                     (let* ((low1  (integer-type-low  type1))
                            (high1 (integer-type-high type1))
                            (low2  (integer-type-low  type2))
                            (high2 (integer-type-high type2)))
                       (setq result-type (list 'INTEGER
                                               (+ low1  low2)
                                               (+ high1 high2)))))
                    ((and (integer-type-p type1)
                          (integer-type-p type2))
                     (let* ((low1  (integer-type-low  type1))
                            (high1 (integer-type-high type1))
                            (low2  (integer-type-low  type2))
                            (high2 (integer-type-high type2)))
                       (cond ((and (integerp low1)
                                   (integerp high1)
                                   (integerp low2)
                                   (integerp high2))
                              (setq result-type (list 'INTEGER
                                                      (+ low1  low2)
                                                      (+ high1 high2))))
                             (t
                              (setq result-type '(INTEGER * *))))))
                    ((and (float-type-p type1)
                          (float-type-p type2))
                     (setq result-type 'FLOAT))))))))
    result-type))

(defknown derive-type-two-arg-- (t) t)
(defun derive-type-two-arg-- (form)
  (let ((args (cdr form))
        (result-type 'NUMBER))
    (when (length-eql args 2)
      (let ((type1 (derive-type (%car args))))
        (when (integer-type-p type1)
           (let ((type2 (derive-type (%cadr args))))
             (when (integer-type-p type2)
               ;; both integer types
               (let* ((low1  (integer-type-low  type1))
                      (high1 (integer-type-high type1))
                      (low2  (integer-type-low  type2))
                      (high2 (integer-type-high type2)))
                 (cond ((and (integerp low1)
                             (integerp high1)
                             (integerp low2)
                             (integerp high2))
                        (setq result-type (list 'INTEGER
                                                (- low1  high2)
                                                (- high1 low2))))
                       (t
                        (setq result-type '(INTEGER * *))))))))))
    result-type))

(defknown derive-type-two-arg-* (t) t)
(defun derive-type-two-arg-* (form)
  (let ((args (cdr form))
        (result-type 'NUMBER))
    (when (length-eql args 2)
      (let ((type1 (derive-type (%car args))))
        (when (neq type1 :unknown)
          (let ((type2 (derive-type (%cadr args))))
            (when (neq type2 :unknown)
              (cond ((and (float-type-p type1)
                          (float-type-p type2))
                     (setq result-type 'FLOAT))
                    ((and (integer-type-p type1)
                          (integer-type-p type2))
                     (setq result-type '(INTEGER * *)))))))))
    result-type))

(defun derive-type-function (form)
  (declare (ignore form))
  'FUNCTION)

(defun derive-type-if (form)
  (let ((result-type :unknown))
    (when (length-eql form 4)
      (let ((type1 (derive-type (third form))))
        (unless (eq type1 :unknown)
          (let ((type2 (derive-type (fourth form))))
            (unless (eq type2 :unknown)
;;               (format t "derive-type-if type1 = ~S type2 = ~S~%" type1 type2)
              (cond ((equal type1 type2)
                     (setq result-type type1))
                    ((and (integer-type-p type1)
                          (integer-type-p type2))
                     (let* ((low1  (integer-type-low  type1))
                            (high1 (integer-type-high type1))
                            (low2  (integer-type-low  type2))
                            (high2 (integer-type-high type2)))
                       (cond ((and (integerp low1)
                                   (integerp high1)
                                   (integerp low2)
                                   (integerp high2))
                              (setq result-type (list 'INTEGER
                                                      (min low1  low2)
                                                      (max high1 high2))))
                             (t
                              (setq result-type '(INTEGER * *))))))
                    ((and (subtypep type1 'NUMBER)
                          (subtypep type2 'NUMBER))
                     (setq result-type 'NUMBER)))
;;               (format t "derive-type-if result-type = ~S~%" result-type)
              )))))
    result-type))

(defun derive-type-let/let* (form)
  (let ((result-type :unknown))
    (when (length-eql form 2)
      (let ((block (%cadr form)))
        (when (block-p block)
          (let ((last-subform (car (last (block-body block)))))
            (setq result-type (derive-type last-subform))))))
    result-type))

(defun derive-type-progn (form)
  (let* ((body (cdr form))
         (last-subform (car (last body))))
    (derive-type last-subform)))

(defun derive-type-reverse/nreverse (form)
  (let ((result-type 'sequence))
    (when (length-eql form 2)
      (let ((type (derive-type (%cadr form))))
        (cond ((eq type :unknown))
              ((subtypep type 'LIST)
               (setq result-type 'LIST))
              ((subtypep type 'VECTOR)
               (setq result-type 'VECTOR)))))
    result-type))

(defun derive-type-quote (form)
  (let ((arg (cadr form)))
    (cond ((null arg)
           'NULL)
          ((symbolp arg)
           'SYMBOL)
          ((consp arg)
           'CONS)
          ((integerp arg)
           (list 'INTEGER arg arg))
          ((numberp arg)
           'NUMBER))))

(defun derive-type-require-structure-type (form)
  (cadr form))

(defun derive-type-require-type (form)
  (canonicalize-type (caddr form)))

(defun derive-type-setq (form)
  (cond ((length-eql form 3)
         (derive-type (%caddr form)))
        (t
         (format t "derive-type-setq unexpected situation~%")
         :unknown)))

(defun derive-type-the (form)
  (canonicalize-type (cadr form)))

(defun derive-type-truly-the (form)
  (canonicalize-type (cadr form)))

(defun derive-type-values (form)
  (let* ((args (cdr form))
         (numargs (length args)))
    (cond ((eql numargs 1)
           (derive-type (%car args)))
          ((> numargs 1)
           (let ((type1 (derive-type (%car args))))
             (cond ((eq type1 :unknown)
                    :unknown)
                   (t
                    (let ((types (make-list (1+ numargs) :initial-element t)))
                      (setf (car types) 'VALUES)
                      (setf (cadr types) type1))))))
          (t
           :unknown))))

(defun install-derive-type-handler (op handler)
  (put op 'derive-type-handler handler))

(install-derive-type-handler 'aref                   'derive-type-aref)
(install-derive-type-handler 'ash                    'derive-type-ash)
(install-derive-type-handler 'coerce                 'derive-type-coerce)
(install-derive-type-handler 'function               'derive-type-function)
(install-derive-type-handler 'if                     'derive-type-if)
(install-derive-type-handler 'let                    'derive-type-let/let*)
(install-derive-type-handler 'let*                   'derive-type-let/let*)
(install-derive-type-handler 'logand                 'derive-type-logand)
(install-derive-type-handler 'logior                 'derive-type-logior/logxor)
(install-derive-type-handler 'logxor                 'derive-type-logior/logxor)
(install-derive-type-handler 'make-array             'derive-type-make-array)
(install-derive-type-handler 'make-simple-vector     'derive-type-make-simple-vector)
(install-derive-type-handler 'nreverse               'derive-type-reverse/nreverse)
(install-derive-type-handler 'progn                  'derive-type-progn)
(install-derive-type-handler 'quote                  'derive-type-quote)
(install-derive-type-handler 'require-structure-type 'derive-type-require-structure-type)
(install-derive-type-handler 'require-type           'derive-type-require-type)
(install-derive-type-handler 'reverse                'derive-type-reverse/nreverse)
(install-derive-type-handler 'row-major-aref         'derive-type-aref)
(install-derive-type-handler 'setq                   'derive-type-setq)
(install-derive-type-handler 'the                    'derive-type-the)
(install-derive-type-handler 'truly-the              'derive-type-truly-the)
(install-derive-type-handler 'two-arg-*              'derive-type-two-arg-*)
(install-derive-type-handler 'two-arg-+              'derive-type-two-arg-+)
(install-derive-type-handler 'two-arg--              'derive-type-two-arg--)
(install-derive-type-handler 'two-arg-logand         'derive-type-logand)
(install-derive-type-handler 'two-arg-logior         'derive-type-logior/logxor)
(install-derive-type-handler 'two-arg-logxor         'derive-type-logior/logxor)
(install-derive-type-handler 'values                 'derive-type-values)
(install-derive-type-handler 'vector-ref             'derive-type-aref)
